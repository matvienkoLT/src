<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.12">
  <compounddef id="group__dbg__funcs" kind="group">
    <compoundname>dbg_funcs</compoundname>
    <title>Debugger functions</title>
    <innergroup refid="group__dbg__funcs__cmds">Process commands</innergroup>
    <innergroup refid="group__dbg__funcs__threads">Threads</innergroup>
    <innergroup refid="group__dbg__funcs__modules">Modules</innergroup>
    <innergroup refid="group__dbg__funcs__flow">Execution flow control</innergroup>
    <innergroup refid="group__dbg__funcs__regs">Registers</innergroup>
    <innergroup refid="group__dbg__funcs__bpts">Breakpoints</innergroup>
    <innergroup refid="group__dbg__funcs__tracing">Tracing</innergroup>
    <innergroup refid="group__dbg__funcs__high">High level functions</innergroup>
    <innergroup refid="group__dbg__funcs__srcinfo">Source information providers</innergroup>
    <innergroup refid="group__dbg__funcs__mem">Debugger memory functions for UI</innergroup>
    <innergroup refid="group__dbg__funcs__conv">Misc</innergroup>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__dbg__funcs_1ga7a7be026d9efa51e8a10936c38a1f50f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool idaapi</type>
        <definition>bool idaapi run_requests</definition>
        <argsstring>(void)</argsstring>
        <name>run_requests</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Execute requests until all requests are processed or an asynchronous function is called. {Type, Synchronous function, Notification, none (synchronous function)} <simplesect kind="return"><para>false if not all requests could be processed (indicates an asynchronous function was started) </para></simplesect>
<simplesect kind="note"><para>If called from a notification handler, the execution of requests will be postponed to the end of the execution of all notification handlers. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/dbg.hpp" line="246" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/dbg.hpp" bodystart="246" bodyend="246"/>
      </memberdef>
      <memberdef kind="function" id="group__dbg__funcs_1gafa6475682b46eb93b8d15054cb5af0ac" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="kernwin_8hpp_1a4a23e389ff9cbf1cd31179ca2f393334" kindref="member">ui_notification_t</ref> idaapi</type>
        <definition>ui_notification_t idaapi get_running_request</definition>
        <argsstring>(void)</argsstring>
        <name>get_running_request</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the current running request. {Type, Synchronous function, Notification, none (synchronous function)} <simplesect kind="return"><para>ui_null if no running request </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/dbg.hpp" line="254" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/dbg.hpp" bodystart="254" bodyend="254"/>
      </memberdef>
      <memberdef kind="function" id="group__dbg__funcs_1ga0d250ba97c49af20ccf106dc9c60417d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool is_request_running</definition>
        <argsstring>(void)</argsstring>
        <name>is_request_running</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
<para>Is a request currently running? </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/dbg.hpp" line="259" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/dbg.hpp" bodystart="259" bodyend="259"/>
      </memberdef>
      <memberdef kind="function" id="group__dbg__funcs_1ga19bdc7609576cd2618c9e43ac1def6ec" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="dbg_8hpp_1ac67a564945a2c1721691aa2f657a908c" kindref="member">dbg_notification_t</ref> idaapi</type>
        <definition>dbg_notification_t idaapi get_running_notification</definition>
        <argsstring>(void)</argsstring>
        <name>get_running_notification</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the notification associated (if any) with the current running request. {Type, Synchronous function, Notification, none (synchronous function)} <simplesect kind="return"><para>dbg_null if no running request </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/dbg.hpp" line="267" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/dbg.hpp" bodystart="267" bodyend="267"/>
      </memberdef>
      <memberdef kind="function" id="group__dbg__funcs_1ga2e491f571ade52bfee75073d46b02bdc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void idaapi</type>
        <definition>void idaapi clear_requests_queue</definition>
        <argsstring>(void)</argsstring>
        <name>clear_requests_queue</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Clear the queue of waiting requests. {Type, Synchronous function, Notification, none (synchronous function)} <simplesect kind="note"><para>If a request is currently running, this one isn&apos;t stopped. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/dbg.hpp" line="275" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/dbg.hpp" bodystart="275" bodyend="275"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Control the debugging of a process.</para><para>Debugger functions complete either SYNCHRONOUSLY or ASYNCHRONOUSLY:</para><para><itemizedlist>
<listitem><para>SYNCHRONOUS FUNCTIONS execute the entire action before the function returns.</para></listitem><listitem><para>ASYNCHRONOUS FUNCTIONS return before the action has executed in its entirety. They simply start the action, but the result of the action will only be available later. For example, <ref refid="group__dbg__funcs__flow_1ga02e3e2c96cd0e07e7b213a88415733c7" kindref="member">run_to()</ref> can execute a lot of instructions before terminating. Such functions provide a notification code to indicate the end of their execution (see the &apos;Notification&apos; keyword in the function documentation). Install a callback using <ref refid="ida_8hpp_1a9ff01a67acece6c7a82871ce43892508" kindref="member">hook_to_notification_point()</ref> to be notified when the action is terminated.</para></listitem></itemizedlist>
</para><para>DEBUGGER COMMANDS are functions who influence the execution of the debugged process. They are available in 2 forms:</para><para><itemizedlist>
<listitem><para>COMMAND(): (e.g. <ref refid="group__dbg__funcs__cmds_1gafde4e91a01fb308d4418512ccb369637" kindref="member">suspend_process()</ref>) In this mode, the command will be directly executed. However, it is forbidden to use asynchronous commands in this mode from a debugger notification handler (see <ref refid="dbg_8hpp_1ac67a564945a2c1721691aa2f657a908c" kindref="member">dbg_notification_t</ref>).</para></listitem><listitem><para>request_COMMAND(): (e.g. <ref refid="group__dbg__funcs__cmds_1ga17e3941d0bb55d22c230d16a9ff155de" kindref="member">request_suspend_process()</ref>) In this mode, a REQUEST to run the command will be memorized at the end of the REQUEST QUEUE (see below). This is mandatory to use this mode for asynchronous commands from a debugger notification handler (see <ref refid="dbg_8hpp_1ac67a564945a2c1721691aa2f657a908c" kindref="member">dbg_notification_t</ref>).</para></listitem></itemizedlist>
</para><para>The REQUEST QUEUE contains a list of planned debugger commands. These commands will be started only in the following cases:</para><para><itemizedlist>
<listitem><para>the previous command terminated, and no call to <ref refid="group__dbg__funcs__cmds_1gafde4e91a01fb308d4418512ccb369637" kindref="member">suspend_process()</ref> or <ref refid="group__dbg__funcs__cmds_1ga8833a43919fac27965ef862bbc2b5073" kindref="member">continue_process()</ref> occurred in the asynchronous function result notification handler (if any).</para></listitem><listitem><para><ref refid="group__dbg__funcs_1ga7a7be026d9efa51e8a10936c38a1f50f" kindref="member">run_requests()</ref> was called. Please note that when called from a debugger notification handler the queued requests will only be started after the execution of all notification handlers.</para></listitem></itemizedlist>
</para><para>A request which fails to start (by returning 0) will generate a <ref refid="dbg_8hpp_1ac67a564945a2c1721691aa2f657a908caee37fa6ba6030fdaf7494d95d0ec017d" kindref="member">dbg_request_error</ref> notification. </para>    </detaileddescription>
  </compounddef>
</doxygen>
