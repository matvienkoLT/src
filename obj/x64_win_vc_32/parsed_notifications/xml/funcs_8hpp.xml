<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.12">
  <compounddef id="funcs_8hpp" kind="file" language="C++">
    <compoundname>funcs.hpp</compoundname>
    <includes refid="range_8hpp" local="no">range.hpp</includes>
    <includes refid="bytes_8hpp" local="no">bytes.hpp</includes>
    <includedby refid="idp_8hpp" local="no">obj/x64_linux_gcc_32_opt/idasdk/idp.hpp</includedby>
    <includedby refid="gdl_8hpp" local="no">obj/x64_linux_gcc_32_opt/idasdk/gdl.hpp</includedby>
    <incdepgraph>
      <node id="410">
        <label>sys/stat.h</label>
      </node>
      <node id="394">
        <label>stdarg.h</label>
      </node>
      <node id="397">
        <label>assert.h</label>
      </node>
      <node id="391">
        <label>ida.hpp</label>
        <link refid="ida_8hpp"/>
        <childnode refid="392" relation="include">
        </childnode>
        <childnode refid="388" relation="include">
        </childnode>
      </node>
      <node id="393">
        <label>stdlib.h</label>
      </node>
      <node id="405">
        <label>io.h</label>
      </node>
      <node id="408">
        <label>fcntl.h</label>
      </node>
      <node id="411">
        <label>llong.hpp</label>
        <link refid="llong_8hpp_source"/>
      </node>
      <node id="403">
        <label>malloc.h</label>
      </node>
      <node id="402">
        <label>string</label>
      </node>
      <node id="407">
        <label>map</label>
      </node>
      <node id="406">
        <label>direct.h</label>
      </node>
      <node id="395">
        <label>stddef.h</label>
      </node>
      <node id="390">
        <label>nalt.hpp</label>
        <link refid="nalt_8hpp"/>
        <childnode refid="391" relation="include">
        </childnode>
        <childnode refid="412" relation="include">
        </childnode>
      </node>
      <node id="413">
        <label>lines.hpp</label>
        <link refid="lines_8hpp"/>
        <childnode refid="391" relation="include">
        </childnode>
      </node>
      <node id="398">
        <label>limits.h</label>
      </node>
      <node id="409">
        <label>sys/types.h</label>
      </node>
      <node id="404">
        <label>string.h</label>
      </node>
      <node id="401">
        <label>new</label>
      </node>
      <node id="387">
        <label>obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp</label>
        <link refid="funcs_8hpp"/>
        <childnode refid="388" relation="include">
        </childnode>
        <childnode refid="389" relation="include">
        </childnode>
      </node>
      <node id="392">
        <label>pro.h</label>
        <link refid="pro_8h"/>
        <childnode refid="393" relation="include">
        </childnode>
        <childnode refid="394" relation="include">
        </childnode>
        <childnode refid="395" relation="include">
        </childnode>
        <childnode refid="396" relation="include">
        </childnode>
        <childnode refid="397" relation="include">
        </childnode>
        <childnode refid="398" relation="include">
        </childnode>
        <childnode refid="399" relation="include">
        </childnode>
        <childnode refid="400" relation="include">
        </childnode>
        <childnode refid="401" relation="include">
        </childnode>
        <childnode refid="402" relation="include">
        </childnode>
        <childnode refid="403" relation="include">
        </childnode>
        <childnode refid="404" relation="include">
        </childnode>
        <childnode refid="405" relation="include">
        </childnode>
        <childnode refid="406" relation="include">
        </childnode>
        <childnode refid="407" relation="include">
        </childnode>
        <childnode refid="408" relation="include">
        </childnode>
        <childnode refid="409" relation="include">
        </childnode>
        <childnode refid="410" relation="include">
        </childnode>
        <childnode refid="411" relation="include">
        </childnode>
      </node>
      <node id="400">
        <label>time.h</label>
      </node>
      <node id="389">
        <label>bytes.hpp</label>
        <link refid="bytes_8hpp"/>
        <childnode refid="390" relation="include">
        </childnode>
        <childnode refid="413" relation="include">
        </childnode>
        <childnode refid="388" relation="include">
        </childnode>
      </node>
      <node id="399">
        <label>ctype.h</label>
      </node>
      <node id="388">
        <label>range.hpp</label>
        <link refid="range_8hpp"/>
      </node>
      <node id="412">
        <label>netnode.hpp</label>
        <link refid="netnode_8hpp"/>
        <childnode refid="388" relation="include">
        </childnode>
      </node>
      <node id="396">
        <label>stdio.h</label>
      </node>
    </incdepgraph>
    <invincdepgraph>
      <node id="421">
        <label>obj/x64_linux_gcc_32_opt/idasdk/intel.hpp</label>
        <link refid="intel_8hpp_source"/>
      </node>
      <node id="424">
        <label>obj/x64_linux_gcc_32_opt/idasdk/ida_highlighter.hpp</label>
        <link refid="ida__highlighter_8hpp_source"/>
      </node>
      <node id="415">
        <label>obj/x64_linux_gcc_32_opt/idasdk/idp.hpp</label>
        <link refid="idp_8hpp"/>
        <childnode refid="416" relation="include">
        </childnode>
        <childnode refid="417" relation="include">
        </childnode>
        <childnode refid="418" relation="include">
        </childnode>
        <childnode refid="420" relation="include">
        </childnode>
        <childnode refid="422" relation="include">
        </childnode>
        <childnode refid="423" relation="include">
        </childnode>
      </node>
      <node id="416">
        <label>obj/x64_linux_gcc_32_opt/idasdk/dbg.hpp</label>
        <link refid="dbg_8hpp"/>
      </node>
      <node id="422">
        <label>obj/x64_linux_gcc_32_opt/idasdk/graph.hpp</label>
        <link refid="graph_8hpp"/>
      </node>
      <node id="426">
        <label>obj/x64_linux_gcc_32_opt/idasdk/gdl.hpp</label>
        <link refid="gdl_8hpp"/>
        <childnode refid="420" relation="include">
        </childnode>
        <childnode refid="422" relation="include">
        </childnode>
      </node>
      <node id="425">
        <label>obj/x64_linux_gcc_32_opt/idasdk/tstfeat.hpp</label>
        <link refid="tstfeat_8hpp_source"/>
      </node>
      <node id="414">
        <label>obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp</label>
        <link refid="funcs_8hpp"/>
        <childnode refid="415" relation="include">
        </childnode>
        <childnode refid="426" relation="include">
        </childnode>
      </node>
      <node id="423">
        <label>obj/x64_linux_gcc_32_opt/idasdk/expr.hpp</label>
        <link refid="expr_8hpp"/>
        <childnode refid="424" relation="include">
        </childnode>
        <childnode refid="425" relation="include">
        </childnode>
      </node>
      <node id="417">
        <label>obj/x64_linux_gcc_32_opt/idasdk/frame.hpp</label>
        <link refid="frame_8hpp"/>
      </node>
      <node id="418">
        <label>obj/x64_linux_gcc_32_opt/idasdk/typeinf.hpp</label>
        <link refid="typeinf_8hpp"/>
        <childnode refid="419" relation="include">
        </childnode>
        <childnode refid="420" relation="include">
        </childnode>
        <childnode refid="421" relation="include">
        </childnode>
      </node>
      <node id="420">
        <label>obj/x64_linux_gcc_32_opt/idasdk/hexrays.hpp</label>
        <link refid="hexrays_8hpp_source"/>
      </node>
      <node id="419">
        <label>obj/x64_linux_gcc_32_opt/idasdk/lumina.hpp</label>
        <link refid="lumina_8hpp_source"/>
      </node>
    </invincdepgraph>
    <innerclass refid="structregarg__t" prot="public">regarg_t</innerclass>
    <innerclass refid="classfunc__t" prot="public">func_t</innerclass>
    <innerclass refid="classlock__func" prot="public">lock_func</innerclass>
    <innerclass refid="classfunc__tail__iterator__t" prot="public">func_tail_iterator_t</innerclass>
    <innerclass refid="classfunc__item__iterator__t" prot="public">func_item_iterator_t</innerclass>
    <innerclass refid="classfunc__parent__iterator__t" prot="public">func_parent_iterator_t</innerclass>
      <sectiondef kind="user-defined">
      <header>Get prev/next address in function</header>
      <description><para>Unlike <ref refid="classfunc__item__iterator__t" kindref="compound">func_item_iterator_t</ref> which always enumerates the main function chunk first, these functions respect linear address ordering. </para></description>
      <memberdef kind="function" id="funcs_8hpp_1a30b0fd3f556586cb9f903142ff2448b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman ea_t ida_export</type>
        <definition>idaman ea_t ida_export get_prev_func_addr</definition>
        <argsstring>(func_t *pfn, ea_t ea)</argsstring>
        <name>get_prev_func_addr</name>
        <param>
          <type><ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="797" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a07e55b1b8a13fb277b458ce1929b2bb2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman ea_t ida_export</type>
        <definition>idaman ea_t ida_export get_next_func_addr</definition>
        <argsstring>(func_t *pfn, ea_t ea)</argsstring>
        <name>get_next_func_addr</name>
        <param>
          <type><ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="798" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <description><para>Functions to work with temporary register argument definitions </para></description>
      <memberdef kind="function" id="funcs_8hpp_1a56f1df7669aedbf122627705a18a938a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman void ida_export</type>
        <definition>idaman void ida_export read_regargs</definition>
        <argsstring>(func_t *pfn)</argsstring>
        <name>read_regargs</name>
        <param>
          <type><ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="805" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a2be8603ccd85da70fcd88dd69d43f477" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman void ida_export</type>
        <definition>idaman void ida_export add_regarg</definition>
        <argsstring>(func_t *pfn, int reg, const tinfo_t &amp;tif, const char *name)</argsstring>
        <name>add_regarg</name>
        <param>
          <type><ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <param>
          <type>int</type>
          <declname>reg</declname>
        </param>
        <param>
          <type>const <ref refid="classtinfo__t" kindref="compound">tinfo_t</ref> &amp;</type>
          <declname>tif</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="806" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="define">
      <memberdef kind="define" id="group___f_u_n_c___1ga9f89bd6c0cf00b4e346266627a5e5b3a" prot="public" static="no">
        <name>FUNC_NORET</name>
        <initializer>0x00000001</initializer>
        <briefdescription>
<para>Function doesn&apos;t return. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="63" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="63" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___f_u_n_c___1ga96692fe2be20e5de1dd446a87d8424dd" prot="public" static="no">
        <name>FUNC_FAR</name>
        <initializer>0x00000002</initializer>
        <briefdescription>
<para>Far function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="64" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="64" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___f_u_n_c___1ga3ad36171134e3e021961c2849e6abfae" prot="public" static="no">
        <name>FUNC_LIB</name>
        <initializer>0x00000004</initializer>
        <briefdescription>
<para>Library function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="65" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="65" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___f_u_n_c___1ga83eb9bcfdebfcce3aaf6e113665739b9" prot="public" static="no">
        <name>FUNC_STATICDEF</name>
        <initializer>0x00000008</initializer>
        <briefdescription>
<para>Static function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="67" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="67" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___f_u_n_c___1ga5c18a77caa51d78fcf13ae598fff4b7c" prot="public" static="no">
        <name>FUNC_FRAME</name>
        <initializer>0x00000010</initializer>
        <briefdescription>
<para>Function uses frame pointer (BP) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="69" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="69" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___f_u_n_c___1gae34804c1dcd3a8d02c3c81b5b6b9ef65" prot="public" static="no">
        <name>FUNC_USERFAR</name>
        <initializer>0x00000020</initializer>
        <briefdescription>
<para>of the function </para>        </briefdescription>
        <detaileddescription>
<para>User has specified far-ness </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="70" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="70" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___f_u_n_c___1ga38d248bf1de00c5bb76bad8590070159" prot="public" static="no">
        <name>FUNC_HIDDEN</name>
        <initializer>0x00000040</initializer>
        <briefdescription>
<para>A hidden function chunk. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="72" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="72" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___f_u_n_c___1ga4c0d02377ae90e10869a3c9130a3d5f4" prot="public" static="no">
        <name>FUNC_THUNK</name>
        <initializer>0x00000080</initializer>
        <briefdescription>
<para>Thunk (jump) function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="73" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="73" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___f_u_n_c___1ga578cedfb8ef7408383fe739c57e35485" prot="public" static="no">
        <name>FUNC_BOTTOMBP</name>
        <initializer>0x00000100</initializer>
        <briefdescription>
<para>BP points to the bottom of the stack frame. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="74" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="74" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___f_u_n_c___1ga5642dcc557a7cc6237a5ad2b0f7518b3" prot="public" static="no">
        <name>FUNC_NORET_PENDING</name>
        <initializer>0x00200</initializer>
        <briefdescription>
<para>This flag is verified upon <ref refid="funcs_8hpp_1ae527c8e35dbe6163ea66f8709a7bfafa" kindref="member">func_does_return()</ref> </para>        </briefdescription>
        <detaileddescription>
<para>Function &apos;non-return&apos; analysis must be performed. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="75" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="75" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___f_u_n_c___1ga705fa62af6e2f9c71165c9e789e6db24" prot="public" static="no">
        <name>FUNC_SP_READY</name>
        <initializer>0x00000400</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>SP-analysis has been performed. If this flag is on, the stack change points should not be not modified anymore. Currently this analysis is performed only for PC </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="77" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="77" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___f_u_n_c___1ga598d4230a03182337e451b4d7e90776b" prot="public" static="no">
        <name>FUNC_FUZZY_SP</name>
        <initializer>0x00000800</initializer>
        <briefdescription>
<para>for example: and esp, 0FFFFFFF0h </para>        </briefdescription>
        <detaileddescription>
<para>Function changes SP in untraceable way, </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="82" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="82" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___f_u_n_c___1ga270dfb7dcdbddab712480e3c9516a1c8" prot="public" static="no">
        <name>FUNC_PROLOG_OK</name>
        <initializer>0x00001000</initializer>
        <briefdescription>
<para>by last SP-analysis </para>        </briefdescription>
        <detaileddescription>
<para>Prolog analysis has be performed </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="84" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="84" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___f_u_n_c___1gaeda3bf9abb0f4029d6e258b878ef7d13" prot="public" static="no">
        <name>FUNC_PURGED_OK</name>
        <initializer>0x00004000</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>&apos;argsize&apos; field has been validated. If this bit is clear and &apos;argsize&apos; is 0, then we do not known the real number of bytes removed from the stack. This bit is handled by the processor module. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="86" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="86" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___f_u_n_c___1ga8193dd74d95481badc272c645e5dc910" prot="public" static="no">
        <name>FUNC_TAIL</name>
        <initializer>0x00008000</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This is a function tail. Other bits must be clear (except <ref refid="group___f_u_n_c___1ga38d248bf1de00c5bb76bad8590070159" kindref="member">FUNC_HIDDEN</ref>). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="92" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="92" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___f_u_n_c___1ga072bad79f877ea68ef3686dc8ae7c293" prot="public" static="no">
        <name>FUNC_LUMINA</name>
        <initializer>0x00010000</initializer>
        <briefdescription>
<para>Function info is provided by Lumina. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="95" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="95" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___m_o_v_e___f_u_n_c___1ga49e802fd7fa28afa28c8685920ed2aa8" prot="public" static="no">
        <name>MOVE_FUNC_OK</name>
        <initializer>0</initializer>
        <briefdescription>
<para>ok </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="372" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="372" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___m_o_v_e___f_u_n_c___1gaed7cff5af7aa06b571dc99bb3dc08d42" prot="public" static="no">
        <name>MOVE_FUNC_NOCODE</name>
        <initializer>1</initializer>
        <briefdescription>
<para>no instruction at &apos;newstart&apos; </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="373" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="373" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___m_o_v_e___f_u_n_c___1ga12adb873df28d8973afac8d9ca526233" prot="public" static="no">
        <name>MOVE_FUNC_BADSTART</name>
        <initializer>2</initializer>
        <briefdescription>
<para>bad new start address </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="374" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="374" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___m_o_v_e___f_u_n_c___1ga42b49a13caa3d3983e3a7e88b71bd9f2" prot="public" static="no">
        <name>MOVE_FUNC_NOFUNC</name>
        <initializer>3</initializer>
        <briefdescription>
<para>no function at &apos;ea&apos; </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="375" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="375" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___m_o_v_e___f_u_n_c___1ga82a79967c372781217e27fef006c4763" prot="public" static="no">
        <name>MOVE_FUNC_REFUSED</name>
        <initializer>4</initializer>
        <briefdescription>
<para>a plugin refused the action </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="376" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="376" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___f_i_n_d___f_u_n_c___f_1gadc06fe8ec5d4434488efb28d79205bdd" prot="public" static="no">
        <name>FIND_FUNC_NORMAL</name>
        <initializer>0x0000</initializer>
        <briefdescription>
<para>stop processing if undefined byte is encountered </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="419" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="419" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___f_i_n_d___f_u_n_c___f_1ga625d181ea2205e5fe3a844f61f1bfca6" prot="public" static="no">
        <name>FIND_FUNC_DEFINE</name>
        <initializer>0x0001</initializer>
        <briefdescription>
<para>create instruction if undefined byte is encountered </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="420" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="420" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___f_i_n_d___f_u_n_c___f_1ga1f9d638c1a974a95cfaa9ee750cef097" prot="public" static="no">
        <name>FIND_FUNC_IGNOREFN</name>
        <initializer>0x0002</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>ignore existing function boundaries. by default the function returns function boundaries if ea belongs to a function. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="421" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="421" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___f_i_n_d___f_u_n_c___f_1ga6c9d7a5331e580e06b9b3ce911f635d7" prot="public" static="no">
        <name>FIND_FUNC_KEEPBD</name>
        <initializer>0x0004</initializer>
        <briefdescription>
<para>just create instructions inside the boundaries. </para>        </briefdescription>
        <detaileddescription>
<para>do not modify incoming function boundaries, </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="424" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="424" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___f_i_n_d___f_u_n_c___r_1ga3e201eff6859ad0590bbe4db125570f0" prot="public" static="no">
        <name>FIND_FUNC_UNDEF</name>
        <initializer>0</initializer>
        <briefdescription>
<para>nfn-&gt;end_ea will have the address of the unexplored byte. </para>        </briefdescription>
        <detaileddescription>
<para>function has instructions that pass execution flow to unexplored bytes. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="431" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="431" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___f_i_n_d___f_u_n_c___r_1gadc3153bb9e99648e6306129e5654b0b2" prot="public" static="no">
        <name>FIND_FUNC_OK</name>
        <initializer>1</initializer>
        <briefdescription>
<para>ok, &apos;nfn&apos; is ready for <ref refid="funcs_8hpp_1a43dfcfff5941536b5b16d5ea160cce8a" kindref="member">add_func()</ref> </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="433" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="433" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___f_i_n_d___f_u_n_c___r_1gae1c77ab371a3816e3d90f1f9f48710bd" prot="public" static="no">
        <name>FIND_FUNC_EXIST</name>
        <initializer>2</initializer>
        <briefdescription>
<para>its bounds are returned in &apos;nfn&apos;. </para>        </briefdescription>
        <detaileddescription>
<para>function exists already. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="434" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="434" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="funcs_8hpp_1acbc5031907dd057a3d76ff9a19fba350" prot="public" static="no">
        <name>DECLARE_FUNC_ITERATORS</name>
        <param><defname>prefix</defname></param>
        <initializer>prefix bool ida_export func_tail_iterator_set(<ref refid="classfunc__tail__iterator__t" kindref="compound">func_tail_iterator_t</ref> *fti, <ref refid="classfunc__t" kindref="compound">func_t</ref> *pfn, ea_t ea);\
prefix bool ida_export func_tail_iterator_set_ea(<ref refid="classfunc__tail__iterator__t" kindref="compound">func_tail_iterator_t</ref> *fti, ea_t ea);\
prefix bool ida_export func_parent_iterator_set(<ref refid="classfunc__parent__iterator__t" kindref="compound">func_parent_iterator_t</ref> *fpi, <ref refid="classfunc__t" kindref="compound">func_t</ref> *pfn);\
prefix bool ida_export func_item_iterator_next(<ref refid="classfunc__item__iterator__t" kindref="compound">func_item_iterator_t</ref> *fii, <ref refid="bytes_8hpp_1ac7890d524959057570f4a60a4f8b42c6" kindref="member">testf_t</ref> *testf, void *ud);\
prefix bool ida_export func_item_iterator_prev(<ref refid="classfunc__item__iterator__t" kindref="compound">func_item_iterator_t</ref> *fii, <ref refid="bytes_8hpp_1ac7890d524959057570f4a60a4f8b42c6" kindref="member">testf_t</ref> *testf, void *ud);\
prefix bool ida_export func_item_iterator_decode_prev_insn(<ref refid="classfunc__item__iterator__t" kindref="compound">func_item_iterator_t</ref> *fii, <ref refid="classinsn__t" kindref="compound">insn_t</ref> *out); \
prefix bool ida_export func_item_iterator_decode_preceding_insn(<ref refid="classfunc__item__iterator__t" kindref="compound">func_item_iterator_t</ref> *fii, <ref refid="pro_8h_1a9f46d9d52bbfcc78bc1836f4f2683da4" kindref="member">eavec_t</ref> *visited, bool *p_farref, <ref refid="classinsn__t" kindref="compound">insn_t</ref> *out);</initializer>
        <briefdescription>
<para>Declare helper functions for <ref refid="classfunc__item__iterator__t" kindref="compound">func_item_iterator_t</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="610" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="610" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___i_d_a_s_g_n___1gac254d7fc6f7d0f1fc23d9ba2b9b0d7f5" prot="public" static="no">
        <name>IDASGN_OK</name>
        <initializer>0</initializer>
        <briefdescription>
<para>ok </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="816" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="816" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___i_d_a_s_g_n___1gadccd43014c7fe84025391684eca0c483" prot="public" static="no">
        <name>IDASGN_BADARG</name>
        <initializer>1</initializer>
        <briefdescription>
<para>bad number of signature </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="817" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="817" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___i_d_a_s_g_n___1ga0ed1e8d15a128423ad7e6ec66a3b1084" prot="public" static="no">
        <name>IDASGN_APPLIED</name>
        <initializer>2</initializer>
        <briefdescription>
<para>signature is already applied </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="818" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="818" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___i_d_a_s_g_n___1ga3cd1a2f59f129c3409b4ba7067671c26" prot="public" static="no">
        <name>IDASGN_CURRENT</name>
        <initializer>3</initializer>
        <briefdescription>
<para>signature is currently being applied </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="819" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="819" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___i_d_a_s_g_n___1ga5fb5f33fa63a75ff1c34d52806419490" prot="public" static="no">
        <name>IDASGN_PLANNED</name>
        <initializer>4</initializer>
        <briefdescription>
<para>signature is planned to be applied </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="820" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="820" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___l_i_b_f_u_n_c___1ga7fd057e3133f0f2ae254f8b12822cc88" prot="public" static="no">
        <name>LIBFUNC_FOUND</name>
        <initializer>0</initializer>
        <briefdescription>
<para>ok, library function is found </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="930" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="930" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___l_i_b_f_u_n_c___1gab0237fbae98b51bc7604039785fc80cf" prot="public" static="no">
        <name>LIBFUNC_NONE</name>
        <initializer>1</initializer>
        <briefdescription>
<para>no, this is not a library function </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="931" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="931" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___l_i_b_f_u_n_c___1ga6ec13a8da35ad737bd87bd1ce0083602" prot="public" static="no">
        <name>LIBFUNC_DELAY</name>
        <initializer>2</initializer>
        <briefdescription>
<para>no decision because of lack of information </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="932" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="932" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="funcs_8hpp_1ab69925eef4a6347fd8f9026225604909" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool is_func_entry</definition>
        <argsstring>(const func_t *pfn)</argsstring>
        <name>is_func_entry</name>
        <param>
          <type>const <ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <briefdescription>
<para>Does function describe a function entry chunk? </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="199" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="199" bodyend="199"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1ac798e57513ae645a9682c4ea695d754d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool is_func_tail</definition>
        <argsstring>(const func_t *pfn)</argsstring>
        <name>is_func_tail</name>
        <param>
          <type>const <ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <briefdescription>
<para>Does function describe a function tail chunk? </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="201" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="201" bodyend="201"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a381aa5ad285df1295afbe5a70825dbf4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman void ida_export</type>
        <definition>idaman void ida_export lock_func_range</definition>
        <argsstring>(const func_t *pfn, bool lock)</argsstring>
        <name>lock_func_range</name>
        <param>
          <type>const <ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>lock</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Lock function pointer Locked pointers are guaranteed to remain valid until they are unlocked. Ranges with locked pointers can not be deleted or moved. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="208" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a5b1b284ab27a052c1276f71e8d5bc091" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export is_func_locked</definition>
        <argsstring>(const func_t *pfn)</argsstring>
        <name>is_func_locked</name>
        <param>
          <type>const <ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <briefdescription>
<para>Is the function pointer locked? </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="227" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1af9fec9907dd6b2d3e737997a0251032f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="classfunc__t" kindref="compound">func_t</ref> *ida_export</type>
        <definition>idaman func_t* ida_export get_func</definition>
        <argsstring>(ea_t ea)</argsstring>
        <name>get_func</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get pointer to function structure by address. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>any address in a function </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>ptr to a function or NULL. This function returns a function entry chunk. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="237" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a3fdde3cac23887c5c536ae79d2f9093b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export get_func_chunknum</definition>
        <argsstring>(func_t *pfn, ea_t ea)</argsstring>
        <name>get_func_chunknum</name>
        <param>
          <type><ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the containing tail chunk of &apos;ea&apos;. <parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>-1</parametername>
</parameternamelist>
<parameterdescription>
<para>means &apos;does not contain ea&apos; </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>means the &apos;pfn&apos; itself contains ea </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>&gt;0</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of the containing function tail chunk </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="245" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a9c1d8703e0e1d004e009d089258ea46f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool func_contains</definition>
        <argsstring>(func_t *pfn, ea_t ea)</argsstring>
        <name>func_contains</name>
        <param>
          <type><ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
<para>Does the given function contain the given address? </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="249" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="249" bodyend="252"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1ae40503b8a0e15e31b016135aedd87267" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool is_same_func</definition>
        <argsstring>(ea_t ea1, ea_t ea2)</argsstring>
        <name>is_same_func</name>
        <param>
          <type>ea_t</type>
          <declname>ea1</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>ea2</declname>
        </param>
        <briefdescription>
<para>Do two addresses belong to the same function? </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="255" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="255" bodyend="259"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a6664330cccc9dec81ac6288bd29c20c3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="classfunc__t" kindref="compound">func_t</ref> *ida_export</type>
        <definition>idaman func_t* ida_export getn_func</definition>
        <argsstring>(size_t n)</argsstring>
        <name>getn_func</name>
        <param>
          <type>size_t</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get pointer to function structure by number. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of function, is in range 0..<ref refid="funcs_8hpp_1a22dd1d91e9eb3d3bab69abed43be3aee" kindref="member">get_func_qty()</ref>-1 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>ptr to a function or NULL. This function returns a function entry chunk. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="266" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a22dd1d91e9eb3d3bab69abed43be3aee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman size_t ida_export</type>
        <definition>idaman size_t ida_export get_func_qty</definition>
        <argsstring>(void)</argsstring>
        <name>get_func_qty</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
<para>Get total number of functions in the program. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="271" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1aa1f8b164bb6112dbc21bfecd4763c58a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export get_func_num</definition>
        <argsstring>(ea_t ea)</argsstring>
        <name>get_func_num</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get ordinal number of a function. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>any address in the function </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>number of function (0..<ref refid="funcs_8hpp_1a22dd1d91e9eb3d3bab69abed43be3aee" kindref="member">get_func_qty()</ref>-1). -1 means &apos;no function at the specified address&apos;. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="279" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1aed19494fa9d9d743cfea120af7b8deb5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="classfunc__t" kindref="compound">func_t</ref> *ida_export</type>
        <definition>idaman func_t* ida_export get_prev_func</definition>
        <argsstring>(ea_t ea)</argsstring>
        <name>get_prev_func</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get pointer to the previous function. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>any address in the program </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>ptr to function or NULL if previous function doesn&apos;t exist </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="286" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1aef63013a60578886a19b1bbfef2fe234" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="classfunc__t" kindref="compound">func_t</ref> *ida_export</type>
        <definition>idaman func_t* ida_export get_next_func</definition>
        <argsstring>(ea_t ea)</argsstring>
        <name>get_next_func</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get pointer to the next function. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>any address in the program </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>ptr to function or NULL if next function doesn&apos;t exist </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="293" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a11fc740f61121d71d6958030fa06e677" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman ea_t ida_export</type>
        <definition>idaman ea_t ida_export get_func_ranges</definition>
        <argsstring>(rangeset_t *ranges, func_t *pfn)</argsstring>
        <name>get_func_ranges</name>
        <param>
          <type><ref refid="classrangeset__t" kindref="compound">rangeset_t</ref> *</type>
          <declname>ranges</declname>
        </param>
        <param>
          <type><ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get function ranges. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ranges</parametername>
</parameternamelist>
<parameterdescription>
<para>buffer to receive the range info </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pfn</parametername>
</parameternamelist>
<parameterdescription>
<para>ptr to function structure </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>end address of the last function range (BADADDR-error) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="301" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1aeadbb1e0b11eae2e34730ede51d1ed38" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="pro_8h_1ab65ed42d67e6c517c746ff2a6a187016" kindref="member">ssize_t</ref> ida_export</type>
        <definition>idaman ssize_t ida_export get_func_cmt</definition>
        <argsstring>(qstring *buf, const func_t *pfn, bool repeatable)</argsstring>
        <name>get_func_cmt</name>
        <param>
          <type><ref refid="pro_8h_1a386c10c6aa4340f1d63df85f40454fce" kindref="member">qstring</ref> *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type>const <ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>repeatable</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get function comment. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>buffer for the comment </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pfn</parametername>
</parameternamelist>
<parameterdescription>
<para>ptr to function structure </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>repeatable</parametername>
</parameternamelist>
<parameterdescription>
<para>get repeatable comment? </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>size of comment or -1 In fact this function works with function chunks too. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="311" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a49070bb3dbf2ca55720d20db3a44c9f0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export set_func_cmt</definition>
        <argsstring>(const func_t *pfn, const char *cmt, bool repeatable)</argsstring>
        <name>set_func_cmt</name>
        <param>
          <type>const <ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>cmt</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>repeatable</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set function comment. This function works with function chunks too. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pfn</parametername>
</parameternamelist>
<parameterdescription>
<para>ptr to function structure </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmt</parametername>
</parameternamelist>
<parameterdescription>
<para>comment string, may be multiline (with &apos;<linebreak/>
&apos;). Use empty str (&quot;&quot;) to delete comment </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>repeatable</parametername>
</parameternamelist>
<parameterdescription>
<para>set repeatable comment? </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="321" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a184f1967b3f6e7d00e02e4d97a41e836" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export update_func</definition>
        <argsstring>(func_t *pfn)</argsstring>
        <name>update_func</name>
        <param>
          <type><ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Update information about a function in the database (<ref refid="classfunc__t" kindref="compound">func_t</ref>). You must not change the function start and end addresses using this function. Use <ref refid="funcs_8hpp_1aea0e8d3e2712894d3b4b3fdea39cd5c3" kindref="member">set_func_start()</ref> and <ref refid="funcs_8hpp_1a7548171011040223d66c8740d7098d32" kindref="member">set_func_end()</ref> for it. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pfn</parametername>
</parameternamelist>
<parameterdescription>
<para>ptr to function structure </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>success </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="330" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a55d69de76e1743db96e0d7ecf7909dc2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export add_func_ex</definition>
        <argsstring>(func_t *pfn)</argsstring>
        <name>add_func_ex</name>
        <param>
          <type><ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Add a new function. If the fn-&gt;end_ea is <ref refid="pro_8h_1a63a7c1cde5fb0cf0d0023d55c742dd4f" kindref="member">BADADDR</ref>, then IDA will try to determine the function bounds by calling find_func_bounds(..., <ref refid="group___f_i_n_d___f_u_n_c___f_1ga625d181ea2205e5fe3a844f61f1bfca6" kindref="member">FIND_FUNC_DEFINE</ref>). <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pfn</parametername>
</parameternamelist>
<parameterdescription>
<para>ptr to filled function structure </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>success </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="339" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a43dfcfff5941536b5b16d5ea160cce8a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool add_func</definition>
        <argsstring>(ea_t ea1, ea_t ea2=BADADDR)</argsstring>
        <name>add_func</name>
        <param>
          <type>ea_t</type>
          <declname>ea1</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>ea2</declname>
          <defval><ref refid="pro_8h_1a63a7c1cde5fb0cf0d0023d55c742dd4f" kindref="member">BADADDR</ref></defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Add a new function. If the function end address is <ref refid="pro_8h_1a63a7c1cde5fb0cf0d0023d55c742dd4f" kindref="member">BADADDR</ref>, then IDA will try to determine the function bounds by calling find_func_bounds(..., <ref refid="group___f_i_n_d___f_u_n_c___f_1ga625d181ea2205e5fe3a844f61f1bfca6" kindref="member">FIND_FUNC_DEFINE</ref>). <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea1</parametername>
</parameternamelist>
<parameterdescription>
<para>start address </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ea2</parametername>
</parameternamelist>
<parameterdescription>
<para>end address </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>success </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="349" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="349" bodyend="353"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1ac8a9f424e35fdf6393b44bf35f36832f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export del_func</definition>
        <argsstring>(ea_t ea)</argsstring>
        <name>del_func</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Delete a function. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>any address in the function entry chunk </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>success </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="360" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1aea0e8d3e2712894d3b4b3fdea39cd5c3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export set_func_start</definition>
        <argsstring>(ea_t ea, ea_t newstart)</argsstring>
        <name>set_func_start</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>newstart</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Move function chunk start address. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>any address in the function </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newstart</parametername>
</parameternamelist>
<parameterdescription>
<para>new end address of the function </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="group___m_o_v_e___f_u_n_c__" kindref="compound">Function move result codes</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="368" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a7548171011040223d66c8740d7098d32" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export set_func_end</definition>
        <argsstring>(ea_t ea, ea_t newend)</argsstring>
        <name>set_func_end</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>newend</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Move function chunk end address. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>any address in the function </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newend</parametername>
</parameternamelist>
<parameterdescription>
<para>new end address of the function </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>success </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="385" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1af4ed5ff5471d43941271df7cb0a54cd0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman void ida_export</type>
        <definition>idaman void ida_export reanalyze_function</definition>
        <argsstring>(func_t *pfn, ea_t ea1=0, ea_t ea2=BADADDR, bool analyze_parents=false)</argsstring>
        <name>reanalyze_function</name>
        <param>
          <type><ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>ea1</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>ea_t</type>
          <declname>ea2</declname>
          <defval><ref refid="pro_8h_1a63a7c1cde5fb0cf0d0023d55c742dd4f" kindref="member">BADADDR</ref></defval>
        </param>
        <param>
          <type>bool</type>
          <declname>analyze_parents</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Reanalyze a function. This function analyzes all chunks of the given function. Optional parameters (ea1, ea2) may be used to narrow the analyzed range. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pfn</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to a function </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ea1</parametername>
</parameternamelist>
<parameterdescription>
<para>start of the range to analyze </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ea2</parametername>
</parameternamelist>
<parameterdescription>
<para>end of range to analyze </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>analyze_parents</parametername>
</parameternamelist>
<parameterdescription>
<para>meaningful only if pfn points to a function tail. if true, all tail parents will be reanalyzed. if false, only the given tail will be reanalyzed. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="398" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1af27a7eb0cc4e210f6ffa21e6aa06e589" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export find_func_bounds</definition>
        <argsstring>(func_t *nfn, int flags)</argsstring>
        <name>find_func_bounds</name>
        <param>
          <type><ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>nfn</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Determine the boundaries of a new function. This function tries to find the start and end addresses of a new function. It calls the module with {func_bounds} in order to fine tune the function boundaries. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>nfn</parametername>
</parameternamelist>
<parameterdescription>
<para>structure to fill with information \ nfn-&gt;start_ea points to the start address of the new function. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>flags</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group___f_i_n_d___f_u_n_c___f" kindref="compound">Find function bounds flags</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="group___f_i_n_d___f_u_n_c___r" kindref="compound">Find function bounds result codes</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="414" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1aaee61d9e3082565c8e941377a5b150c5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="pro_8h_1ab65ed42d67e6c517c746ff2a6a187016" kindref="member">ssize_t</ref> ida_export</type>
        <definition>idaman ssize_t ida_export get_func_name</definition>
        <argsstring>(qstring *out, ea_t ea)</argsstring>
        <name>get_func_name</name>
        <param>
          <type><ref refid="pro_8h_1a386c10c6aa4340f1d63df85f40454fce" kindref="member">qstring</ref> *</type>
          <declname>out</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get function name. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>out</parametername>
</parameternamelist>
<parameterdescription>
<para>buffer for the answer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>any address in the function </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>length of the function name </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="444" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1acaa98c6848186d239d12588f84e7c2e5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman asize_t ida_export</type>
        <definition>idaman asize_t ida_export calc_func_size</definition>
        <argsstring>(func_t *pfn)</argsstring>
        <name>calc_func_size</name>
        <param>
          <type><ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Calculate function size. This function takes into account all fragments of the function. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pfn</parametername>
</parameternamelist>
<parameterdescription>
<para>ptr to function structure </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="451" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1ac1c60a7de477ea88c24a5cecf5722942" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export get_func_bitness</definition>
        <argsstring>(const func_t *pfn)</argsstring>
        <name>get_func_bitness</name>
        <param>
          <type>const <ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get function bitness (which is equal to the function segment bitness). pfn==NULL =&gt; returns 0 <parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>16 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>1</parametername>
</parameternamelist>
<parameterdescription>
<para>32 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>2</parametername>
</parameternamelist>
<parameterdescription>
<para>64 </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="460" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a9717f0f01699931eb94276d3c529b34c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int idaapi</type>
        <definition>int idaapi get_func_bits</definition>
        <argsstring>(const func_t *pfn)</argsstring>
        <name>get_func_bits</name>
        <param>
          <type>const <ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <briefdescription>
<para>Get number of bits in the function addressing. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="463" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="463" bodyend="463"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1af46de47bb9d73604bde35ed252b638cd" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int idaapi</type>
        <definition>int idaapi get_func_bytes</definition>
        <argsstring>(const func_t *pfn)</argsstring>
        <name>get_func_bytes</name>
        <param>
          <type>const <ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <briefdescription>
<para>Get number of bytes in the function addressing. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="466" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="466" bodyend="466"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1af43324a92becc4d10ff14387339d68e0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool is_visible_func</definition>
        <argsstring>(func_t *pfn)</argsstring>
        <name>is_visible_func</name>
        <param>
          <type><ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <briefdescription>
<para>Is the function visible (not hidden)? </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="471" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="471" bodyend="471"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1adc3196f5735da224e4f5a42dd30f2786" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool is_finally_visible_func</definition>
        <argsstring>(func_t *pfn)</argsstring>
        <name>is_finally_visible_func</name>
        <param>
          <type><ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <briefdescription>
<para>Is the function visible (event after considering <ref refid="group___s_w___c_1gabb9142b4f649257f9b5f789b689cbf6b" kindref="member">SW_SHHID_FUNC</ref>)? </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="474" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="474" bodyend="475"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1ae5b430fb82b48859c63faf67a73c2200" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman void ida_export</type>
        <definition>idaman void ida_export set_visible_func</definition>
        <argsstring>(func_t *pfn, bool visible)</argsstring>
        <name>set_visible_func</name>
        <param>
          <type><ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>visible</declname>
        </param>
        <briefdescription>
<para>Set visibility of function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="479" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a1ce3d589a62220b86154f5b43bd9d51a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export set_func_name_if_jumpfunc</definition>
        <argsstring>(func_t *pfn, const char *oldname)</argsstring>
        <name>set_func_name_if_jumpfunc</name>
        <param>
          <type><ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>oldname</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Give a meaningful name to function if it consists of only &apos;jump&apos; instruction. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pfn</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to function (may be NULL) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>oldname</parametername>
</parameternamelist>
<parameterdescription>
<para>old name of function. if old name was in &quot;j_...&quot; form, then we may discard it and set a new name. if oldname is not known, you may pass NULL. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>success </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="490" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a3819926f1d7697e0eb65015230c1e3d7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman ea_t ida_export</type>
        <definition>idaman ea_t ida_export calc_thunk_func_target</definition>
        <argsstring>(func_t *pfn, ea_t *fptr)</argsstring>
        <name>calc_thunk_func_target</name>
        <param>
          <type><ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <param>
          <type>ea_t *</type>
          <declname>fptr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Calculate target of a thunk function. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pfn</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to function (may not be NULL) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fptr</parametername>
</parameternamelist>
<parameterdescription>
<para>out: will hold address of a function pointer (if indirect jump) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the target function or <ref refid="pro_8h_1a63a7c1cde5fb0cf0d0023d55c742dd4f" kindref="member">BADADDR</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="498" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1ae527c8e35dbe6163ea66f8709a7bfafa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export func_does_return</definition>
        <argsstring>(ea_t callee)</argsstring>
        <name>func_does_return</name>
        <param>
          <type>ea_t</type>
          <declname>callee</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Does the function return?. To calculate the answer, <ref refid="group___f_u_n_c___1ga9f89bd6c0cf00b4e346266627a5e5b3a" kindref="member">FUNC_NORET</ref> flag and is_noret() are consulted The latter is required for imported functions in the .idata section. Since in .idata we have only function pointers but not functions, we have to introduce a special flag for them. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="507" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a65cb55474c9f4d9bbea12873dcf4fbcc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export reanalyze_noret_flag</definition>
        <argsstring>(ea_t ea)</argsstring>
        <name>reanalyze_noret_flag</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Plan to reanalyze noret flag. This function does not remove FUNC_NORET if it is already present. It just plans to reanalysis. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="514" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a1f68e84613300162cc0d23e79250c4d9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export set_noret_insn</definition>
        <argsstring>(ea_t insn_ea, bool noret)</argsstring>
        <name>set_noret_insn</name>
        <param>
          <type>ea_t</type>
          <declname>insn_ea</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>noret</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Signal a non-returning instruction. This function can be used by the processor module to tell the kernel about non-returning instructions (like call exit). The kernel will perform the global function analysis and find out if the function returns at all. This analysis will be done at the first call to <ref refid="funcs_8hpp_1ae527c8e35dbe6163ea66f8709a7bfafa" kindref="member">func_does_return()</ref> <simplesect kind="return"><para>true if the instruction &apos;noret&apos; flag has been changed </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="524" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a3062576bdeb6fb6fc123e74fc2939efb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="classfunc__t" kindref="compound">func_t</ref> *ida_export</type>
        <definition>idaman func_t* ida_export get_fchunk</definition>
        <argsstring>(ea_t ea)</argsstring>
        <name>get_fchunk</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get pointer to function chunk structure by address. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>any address in a function chunk </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>ptr to a function chunk or NULL. This function may return a function entry as well as a function tail. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="535" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a4c84a87f6299f0724f8f1883ca778620" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="classfunc__t" kindref="compound">func_t</ref> *ida_export</type>
        <definition>idaman func_t* ida_export getn_fchunk</definition>
        <argsstring>(int n)</argsstring>
        <name>getn_fchunk</name>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get pointer to function chunk structure by number. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of function chunk, is in range 0..<ref refid="funcs_8hpp_1aa10ff5e98bb6bb48e48cadf69cadd54f" kindref="member">get_fchunk_qty()</ref>-1 </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>ptr to a function chunk or NULL. This function may return a function entry as well as a function tail. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="543" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1aa10ff5e98bb6bb48e48cadf69cadd54f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman size_t ida_export</type>
        <definition>idaman size_t ida_export get_fchunk_qty</definition>
        <argsstring>(void)</argsstring>
        <name>get_fchunk_qty</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
<para>Get total number of function chunks in the program. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="548" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1aa5fe102694ea5e127bfb3f81d65cf39c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export get_fchunk_num</definition>
        <argsstring>(ea_t ea)</argsstring>
        <name>get_fchunk_num</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get ordinal number of a function chunk in the global list of function chunks. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>any address in the function chunk </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>number of function chunk (0..<ref refid="funcs_8hpp_1aa10ff5e98bb6bb48e48cadf69cadd54f" kindref="member">get_fchunk_qty()</ref>-1). -1 means &apos;no function chunk at the specified address&apos;. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="556" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1ae1a94addf4c657d4a718318936d505df" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="classfunc__t" kindref="compound">func_t</ref> *ida_export</type>
        <definition>idaman func_t* ida_export get_prev_fchunk</definition>
        <argsstring>(ea_t ea)</argsstring>
        <name>get_prev_fchunk</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get pointer to the previous function chunk in the global list. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>any address in the program </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>ptr to function chunk or NULL if previous function chunk doesn&apos;t exist </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="563" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1ade067f329670a1a2b4f4bd6b6dfacf20" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="classfunc__t" kindref="compound">func_t</ref> *ida_export</type>
        <definition>idaman func_t* ida_export get_next_fchunk</definition>
        <argsstring>(ea_t ea)</argsstring>
        <name>get_next_fchunk</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get pointer to the next function chunk in the global list. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>any address in the program </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>ptr to function chunk or NULL if next function chunk doesn&apos;t exist </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="570" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a52f9ee11e7bb8a270a3cbe3714eeb5fd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export append_func_tail</definition>
        <argsstring>(func_t *pfn, ea_t ea1, ea_t ea2)</argsstring>
        <name>append_func_tail</name>
        <param>
          <type><ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>ea1</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>ea2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Append a new tail chunk to the function definition. If the tail already exists, then it will simply be added to the function tail list Otherwise a new tail will be created and its owner will be set to be our function If a new tail can not be created, then this function will fail. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea1</parametername>
</parameternamelist>
<parameterdescription>
<para>start of the tail. If a tail already exists at the specified address it must start at &apos;ea1&apos; </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ea2</parametername>
</parameternamelist>
<parameterdescription>
<para>end of the tail. If a tail already exists at the specified address it must end at &apos;ea2&apos;. If specified as BADADDR, IDA will determine the end address itself. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="586" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1ae7c614485023e2bb894f6c304244e120" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export remove_func_tail</definition>
        <argsstring>(func_t *pfn, ea_t tail_ea)</argsstring>
        <name>remove_func_tail</name>
        <param>
          <type><ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>tail_ea</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Remove a function tail. If the tail belongs only to one function, it will be completely removed. Otherwise if the function was the tail owner, the first function using this tail becomes the owner of the tail. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="594" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1ac0111894398bef00303b816851f54a27" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export set_tail_owner</definition>
        <argsstring>(func_t *fnt, ea_t func_start)</argsstring>
        <name>set_tail_owner</name>
        <param>
          <type><ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>fnt</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>func_start</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set a function as the possessing function of a function tail. The function should already refer to the tail (after append_func_tail). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="600" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1aa00b8b1556a613caad16122649dd77bf" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="pro_8h_1acb0b22a01885ebdb9ac572343bbc4dab" kindref="member">THREAD_SAFE</ref> bool idaapi</type>
        <definition>THREAD_SAFE bool idaapi f_any</definition>
        <argsstring>(flags_t, void *)</argsstring>
        <name>f_any</name>
        <param>
          <type><ref refid="pro_8h_1a55dd00e03168fb5180830e87ef0a2c57" kindref="member">flags_t</ref></type>
        </param>
        <param>
          <type>void *</type>
        </param>
        <briefdescription>
<para>Helper function to accept any address. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="621" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" bodystart="621" bodyend="621"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1ae8d474ef2ca5f96d214640ffb05c3fae" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman void ida_export</type>
        <definition>idaman void ida_export iterate_func_chunks</definition>
        <argsstring>(func_t *pfn, void(idaapi *func)(ea_t ea1, ea_t ea2, void *ud), void *ud=NULL, bool include_parents=false)</argsstring>
        <name>iterate_func_chunks</name>
        <param>
          <type><ref refid="classfunc__t" kindref="compound">func_t</ref> *</type>
          <declname>pfn</declname>
        </param>
        <param>
          <type>void(idaapi *)(ea_t ea1, ea_t ea2, void *ud)</type>
          <declname>func</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>ud</declname>
          <defval>NULL</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>include_parents</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function to iterate function chunks (all of them including the entry chunk) <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pfn</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the function </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>function to call for each chunk </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ud</parametername>
</parameternamelist>
<parameterdescription>
<para>user data for &apos;func&apos; </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>include_parents</parametername>
</parameternamelist>
<parameterdescription>
<para>meaningful only if pfn points to a function tail. if true, all tail parents will be iterated. if false, only the given tail will be iterated. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="696" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a21aa2dc515f7b37cbdc393eb789d9c4d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export plan_to_apply_idasgn</definition>
        <argsstring>(const char *fname)</argsstring>
        <name>plan_to_apply_idasgn</name>
        <param>
          <type>const char *</type>
          <declname>fname</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Add a signature file to the list of planned signature files. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fname</parametername>
</parameternamelist>
<parameterdescription>
<para>file name. should not contain directory part. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 if failed, otherwise number of planned (and applied) signatures </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="827" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a11aee0876bd2f234cbb3cc11aa69dbca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export apply_idasgn_to</definition>
        <argsstring>(const char *signame, ea_t ea, bool is_startup)</argsstring>
        <name>apply_idasgn_to</name>
        <param>
          <type>const char *</type>
          <declname>signame</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>is_startup</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Apply a signature file to the specified address. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>signame</parametername>
</parameternamelist>
<parameterdescription>
<para>short name of signature file (the file name without path) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>address to apply the signature </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>is_startup</parametername>
</parameternamelist>
<parameterdescription>
<para>if set, then the signature is treated as a startup one for startup signature ida doesn&apos;t rename the first function of the applied module. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="group___l_i_b_f_u_n_c__" kindref="compound">Library function codes</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="838" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a053a76d76510369e88182b93c1289ce8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export get_idasgn_qty</definition>
        <argsstring>(void)</argsstring>
        <name>get_idasgn_qty</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get number of signatures in the list of planned and applied signatures. <simplesect kind="return"><para>0..n </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="844" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a1bc01ee0b7011b7cc2d42ce314bfe0ef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export get_current_idasgn</definition>
        <argsstring>(void)</argsstring>
        <name>get_current_idasgn</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get number of the the current signature. <simplesect kind="return"><para>0..n-1 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="850" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1adac32c36269d53db5a14273b7ee09d03" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export calc_idasgn_state</definition>
        <argsstring>(int n)</argsstring>
        <name>calc_idasgn_state</name>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get state of a signature in the list of planned signatures <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of signature in the list (0..<ref refid="funcs_8hpp_1a053a76d76510369e88182b93c1289ce8" kindref="member">get_idasgn_qty()</ref>-1) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>state of signature or <ref refid="group___i_d_a_s_g_n___1gadccd43014c7fe84025391684eca0c483" kindref="member">IDASGN_BADARG</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="857" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a3431fb53c0c6e4ec9519348d60722a5b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export del_idasgn</definition>
        <argsstring>(int n)</argsstring>
        <name>del_idasgn</name>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Remove signature from the list of planned signatures. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of signature in the list (0..<ref refid="funcs_8hpp_1a053a76d76510369e88182b93c1289ce8" kindref="member">get_idasgn_qty()</ref>-1) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="group___i_d_a_s_g_n___1gac254d7fc6f7d0f1fc23d9ba2b9b0d7f5" kindref="member">IDASGN_OK</ref>, <ref refid="group___i_d_a_s_g_n___1gadccd43014c7fe84025391684eca0c483" kindref="member">IDASGN_BADARG</ref>, <ref refid="group___i_d_a_s_g_n___1ga0ed1e8d15a128423ad7e6ec66a3b1084" kindref="member">IDASGN_APPLIED</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="864" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a236eb154300e347420506e61ec20f76f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="pro_8h_1a56f1a81c92849566ae864511088eb7e8" kindref="member">int32</ref> ida_export</type>
        <definition>idaman int32 ida_export get_idasgn_desc</definition>
        <argsstring>(qstring *signame, qstring *optlibs, int n)</argsstring>
        <name>get_idasgn_desc</name>
        <param>
          <type><ref refid="pro_8h_1a386c10c6aa4340f1d63df85f40454fce" kindref="member">qstring</ref> *</type>
          <declname>signame</declname>
        </param>
        <param>
          <type><ref refid="pro_8h_1a386c10c6aa4340f1d63df85f40454fce" kindref="member">qstring</ref> *</type>
          <declname>optlibs</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get information about a signature in the list. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>signame</parametername>
</parameternamelist>
<parameterdescription>
<para>buffer for the name of the signature. (short form, only base name without the directory part will be stored). if signame == NULL, then the name won&apos;t be returned. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>optlibs</parametername>
</parameternamelist>
<parameterdescription>
<para>buffer for the names of the optional libraries if optlibs == NULL, then the optional libraries are not returned </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of signature in the list (0..<ref refid="funcs_8hpp_1a053a76d76510369e88182b93c1289ce8" kindref="member">get_idasgn_qty()</ref>-1) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>number of successfully recognized modules using this signature. -1 means the &apos;n&apos; is a bad argument, i.e. no signature with this number exists.. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="879" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a9c6ffc0f0c9bb8ee8ce4c01474cc5e31" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="classidasgn__t" kindref="compound">idasgn_t</ref> *ida_export</type>
        <definition>idaman idasgn_t* ida_export get_idasgn_header_by_short_name</definition>
        <argsstring>(const char *name)</argsstring>
        <name>get_idasgn_header_by_short_name</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get idasgn header by a short signature name. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>short name of a signature </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>NULL if can&apos;t find the signature </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="891" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1ad85bd713ec5c3fda0e79ca0203107c03" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="pro_8h_1ab65ed42d67e6c517c746ff2a6a187016" kindref="member">ssize_t</ref> ida_export</type>
        <definition>idaman ssize_t ida_export get_idasgn_title</definition>
        <argsstring>(qstring *buf, const char *name)</argsstring>
        <name>get_idasgn_title</name>
        <param>
          <type><ref refid="pro_8h_1a386c10c6aa4340f1d63df85f40454fce" kindref="member">qstring</ref> *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get full description of the signature by its short name. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>the output buffer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>short name of a signature </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>size of signature description or -1 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="899" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1af1c187a31ca0b6379001ed49babe03cc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman void ida_export</type>
        <definition>idaman void ida_export determine_rtl</definition>
        <argsstring>(void)</argsstring>
        <name>determine_rtl</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Determine compiler/vendor using the startup signatures. If determined, then appropriate signature files are included into the list of planned signature files. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="907" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1a2a89d1f765c7d13738e85333473a2f6e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export apply_startup_sig</definition>
        <argsstring>(ea_t ea, const char *startup)</argsstring>
        <name>apply_startup_sig</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>startup</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Apply a startup signature file to the specified address. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>address to apply the signature to; usually {start_ea} </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>startup</parametername>
</parameternamelist>
<parameterdescription>
<para>the name of the signature file without path and extension </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if successfully applied the signature </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="915" column="1"/>
      </memberdef>
      <memberdef kind="function" id="funcs_8hpp_1afb69ff17eadf468ac080c807027d5526" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export try_to_add_libfunc</definition>
        <argsstring>(ea_t ea)</argsstring>
        <name>try_to_add_libfunc</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Apply the currently loaded signature file to the specified address. If a library function is found, then create a function and name it accordingly. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>any address in the program </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="group___l_i_b_f_u_n_c__" kindref="compound">Library function codes</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp" line="924" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Routines for working with functions within the disassembled program. </para>    </briefdescription>
    <detaileddescription>
<para>This file also contains routines for working with library signatures (e.g. FLIRT).</para><para>Each function consists of function chunks. At least one function chunk must be present in the function definition - the function entry chunk. Other chunks are called function tails. There may be several of them for a function.</para><para>A function tail is a continuous range of addresses. It can be used in the definition of one or more functions. One function using the tail is singled out and called the tail owner. This function is considered as &apos;possessing&apos; the tail. <ref refid="funcs_8hpp_1af9fec9907dd6b2d3e737997a0251032f" kindref="member">get_func()</ref> on a tail address will return the function possessing the tail. You can enumerate the functions using the tail by using <ref refid="classfunc__parent__iterator__t" kindref="compound">func_parent_iterator_t</ref>.</para><para>Each function chunk in the disassembly is represented as an &quot;range&quot; (a range of addresses, see <ref refid="range_8hpp" kindref="compound">range.hpp</ref> for details) with characteristics.</para><para>A function entry must start with an instruction (code) byte. </para>    </detaileddescription>
    <location file="obj/x64_linux_gcc_32_opt/idasdk/funcs.hpp"/>
  </compounddef>
</doxygen>
