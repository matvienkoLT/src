<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.12">
  <compounddef id="lex_8hpp" kind="file" language="C++">
    <compoundname>lex.hpp</compoundname>
    <includedby refid="parsejson_8hpp" local="no">obj/x64_linux_gcc_32_opt/idasdk/parsejson.hpp</includedby>
    <includedby refid="tstfeat_8hpp" local="no">obj/x64_linux_gcc_32_opt/idasdk/tstfeat.hpp</includedby>
    <includedby refid="parseucdr_8hpp" local="no">obj/x64_linux_gcc_32_opt/idasdk/parseucdr.hpp</includedby>
    <includedby refid="parse_8hpp" local="no">obj/x64_linux_gcc_32_opt/idasdk/parse.hpp</includedby>
    <invincdepgraph>
      <node id="841">
        <label>obj/x64_linux_gcc_32_opt/idasdk/parsejson.hpp</label>
        <link refid="parsejson_8hpp"/>
      </node>
      <node id="843">
        <label>obj/x64_linux_gcc_32_opt/idasdk/parseucdr.hpp</label>
        <link refid="parseucdr_8hpp_source"/>
      </node>
      <node id="844">
        <label>obj/x64_linux_gcc_32_opt/idasdk/parse.hpp</label>
        <link refid="parse_8hpp_source"/>
      </node>
      <node id="842">
        <label>obj/x64_linux_gcc_32_opt/idasdk/tstfeat.hpp</label>
        <link refid="tstfeat_8hpp_source"/>
      </node>
      <node id="840">
        <label>obj/x64_linux_gcc_32_opt/idasdk/lex.hpp</label>
        <link refid="lex_8hpp"/>
        <childnode refid="841" relation="include">
        </childnode>
        <childnode refid="842" relation="include">
        </childnode>
        <childnode refid="843" relation="include">
        </childnode>
        <childnode refid="844" relation="include">
        </childnode>
      </node>
    </invincdepgraph>
    <innerclass refid="structtoken__t" prot="public">token_t</innerclass>
    <innerclass refid="structcast__t" prot="public">cast_t</innerclass>
    <innerclass refid="structlex__value__t" prot="public">lex_value_t</innerclass>
      <sectiondef kind="user-defined">
      <header>String oriented functions</header>
      <memberdef kind="function" id="lex_8hpp_1a7e8fa8491fe016e56d7a3f24cb1f27f1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="pro_8h_1a84c6c720bb5e612c64013a7d4e8acd55" kindref="member">error_t</ref> ida_export</type>
        <definition>idaman error_t ida_export lex_init_string</definition>
        <argsstring>(lexer_t *lx, const char *line, macro_t **macros=NULL)</argsstring>
        <name>lex_init_string</name>
        <param>
          <type>lexer_t *</type>
          <declname>lx</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>line</declname>
        </param>
        <param>
          <type>macro_t **</type>
          <declname>macros</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set the input line and the macro table. if macros==NULL, the macro table will not be changed. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="293" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>File oriented functions</header>
      <memberdef kind="function" id="lex_8hpp_1a71f853f002a3ad6ba31da876cd6d647f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="pro_8h_1a84c6c720bb5e612c64013a7d4e8acd55" kindref="member">error_t</ref> ida_export</type>
        <definition>idaman error_t ida_export lex_init_file</definition>
        <argsstring>(lexer_t *lx, const char *file)</argsstring>
        <name>lex_init_file</name>
        <param>
          <type>lexer_t *</type>
          <declname>lx</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>file</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initialization: file may be NULL. Also see <ref refid="lex_8hpp_1a6223a6c446524cde5c67d76f706b1a2b" kindref="member">lex_term_file()</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="306" column="1"/>
      </memberdef>
      <memberdef kind="function" id="lex_8hpp_1a5ff4d39a3861b29b63e12b210685e804" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman const char *ida_export</type>
        <definition>idaman const char* ida_export lex_get_file_line</definition>
        <argsstring>(lexer_t *lx, int32 *linenum, const char **lineptr, int level=0)</argsstring>
        <name>lex_get_file_line</name>
        <param>
          <type>lexer_t *</type>
          <declname>lx</declname>
        </param>
        <param>
          <type><ref refid="pro_8h_1a56f1a81c92849566ae864511088eb7e8" kindref="member">int32</ref> *</type>
          <declname>linenum</declname>
        </param>
        <param>
          <type>const char **</type>
          <declname>lineptr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>level</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Error handling. if level &gt; 0, then return information about the enclosing file which included the current one. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="313" column="1"/>
      </memberdef>
      <memberdef kind="function" id="lex_8hpp_1a6223a6c446524cde5c67d76f706b1a2b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman void ida_export</type>
        <definition>idaman void ida_export lex_term_file</definition>
        <argsstring>(lexer_t *lx, bool del_macros)</argsstring>
        <name>lex_term_file</name>
        <param>
          <type>lexer_t *</type>
          <declname>lx</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>del_macros</declname>
        </param>
        <briefdescription>
<para>Termination: also see <ref refid="lex_8hpp_1a71f853f002a3ad6ba31da876cd6d647f" kindref="member">lex_init_file()</ref> </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="322" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Token stack</header>
      <memberdef kind="typedef" id="lex_8hpp_1ab32c8e62185bb40333dc7fa5e52c83f7" prot="public" static="no">
        <type><ref refid="classqstack" kindref="compound">qstack</ref>&lt; <ref refid="structtoken__t" kindref="compound">token_t</ref> &gt;</type>
        <definition>typedef qstack&lt;token_t&gt; tokenstack_t</definition>
        <argsstring></argsstring>
        <name>tokenstack_t</name>
        <briefdescription>
<para>see <ref refid="lex_8hpp_1a9459eaccf53dc8b7cc50b1b2980705ee" kindref="member">get_token()</ref>, <ref refid="lex_8hpp_1aabfb89b5f4ffc9140054ebbe3dd4075d" kindref="member">unget_token()</ref> </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="328" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="328" bodyend="-1"/>
      </memberdef>
      <memberdef kind="function" id="lex_8hpp_1a9459eaccf53dc8b7cc50b1b2980705ee" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool get_token</definition>
        <argsstring>(token_t *t, lexer_t *lx, tokenstack_t &amp;buf)</argsstring>
        <name>get_token</name>
        <param>
          <type><ref refid="structtoken__t" kindref="compound">token_t</ref> *</type>
          <declname>t</declname>
        </param>
        <param>
          <type>lexer_t *</type>
          <declname>lx</declname>
        </param>
        <param>
          <type><ref refid="lex_8hpp_1ab32c8e62185bb40333dc7fa5e52c83f7" kindref="member">tokenstack_t</ref> &amp;</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Retrieve token from a stack or lexer. If buf is not empty then get the token on top of the stack. If buf is empty then gen the next token from the lexer. <simplesect kind="return"><para>success </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="336" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="336" bodyend="343"/>
      </memberdef>
      <memberdef kind="function" id="lex_8hpp_1aabfb89b5f4ffc9140054ebbe3dd4075d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void unget_token</definition>
        <argsstring>(const token_t &amp;t, tokenstack_t &amp;buf)</argsstring>
        <name>unget_token</name>
        <param>
          <type>const <ref refid="structtoken__t" kindref="compound">token_t</ref> &amp;</type>
          <declname>t</declname>
        </param>
        <param>
          <type><ref refid="lex_8hpp_1ab32c8e62185bb40333dc7fa5e52c83f7" kindref="member">tokenstack_t</ref> &amp;</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>Push a token back onto the token stack. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="348" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="348" bodyend="351"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="define">
      <memberdef kind="define" id="group___l_x_o_p_t___1ga068126be2f22c1e330948652d5ce5025" prot="public" static="no">
        <name>LXOPT_PARSE_FLOATS</name>
        <initializer>0x0001</initializer>
        <briefdescription>
<para>enable floating point constants </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="256" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="256" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___l_x_o_p_t___1ga37c2344a1de5baa94ff11c504a0563e8" prot="public" static="no">
        <name>LXOPT_REQ_SEPARATOR</name>
        <initializer>0x0002</initializer>
        <briefdescription>
<para>require a separator between a number and an ident or a character/string constant or dot </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="257" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="257" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___l_x_o_p_t___1ga7c1718358d99f1ee5230241ce4915f31" prot="public" static="no">
        <name>LXOPT_NOCASE_FILES</name>
        <initializer>0x0004</initializer>
        <briefdescription>
<para>case-insensitive file search </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="258" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="258" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___l_x_o_p_t___1gaab71b38807f79493f7354238690db906" prot="public" static="no">
        <name>LXOPT_C99_CONSTANTS</name>
        <initializer>0x0008</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>the size and sign of constants depend on the value itself and the &apos;U&apos;, &apos;L&apos;, and &apos;LL&apos; modifier suffixes. otherwise the constant is always considered as signed and the size depends only on the number of bytes in the value </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="259" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="259" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="lex_8hpp_1a89b503fa5c6813a8c60627d2335d49c3" prot="public" static="no">
        <type><ref refid="pro_8h_1ab95f123a6c9bcfee6a343170ef8c5f69" kindref="member">ushort</ref></type>
        <definition>typedef ushort lxtype</definition>
        <argsstring></argsstring>
        <name>lxtype</name>
        <briefdescription>
<para>see <ref refid="group__lx__" kindref="compound">Parser token types</ref> </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="19" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="19" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="lex_8hpp_1a723b271f3ba645fbf7511d952bf7df2f" prot="public" static="no">
        <type><ref refid="pro_8h_1a84c6c720bb5e612c64013a7d4e8acd55" kindref="member">error_t</ref></type>
        <definition>typedef error_t lx_resolver_t(lexer_t *lx, void *ud, token_t *curtok, sval_t *res)</definition>
        <argsstring>(lexer_t *lx, void *ud, token_t *curtok, sval_t *res)</argsstring>
        <name>lx_resolver_t</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Preprocessor callback for unknown tokens. Will be called when preprocessor calculates the value of #if expression. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="72" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="72" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="lex_8hpp_1adc7813835f2b1b8c8b89bd4236d19590" prot="public" static="no">
        <type><ref refid="pro_8h_1a84c6c720bb5e612c64013a7d4e8acd55" kindref="member">error_t</ref></type>
        <definition>typedef error_t lx_parse_cast_t(lexer_t *lx, cast_t *cast, token_t *ct)</definition>
        <argsstring>(lexer_t *lx, cast_t *cast, token_t *ct)</argsstring>
        <name>lx_parse_cast_t</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Preprocessor callbacks for casts. Will be called when preprocessor calculates the value of #if expression. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="178" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="178" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="lex_8hpp_1af772cf7e5990fcea01360ae8b76728a5" prot="public" static="no">
        <type>int idaapi</type>
        <definition>typedef int idaapi lx_preprocessor_cb(void *ud, const char *fname, int nl, const char *line)</definition>
        <argsstring>(void *ud, const char *fname, int nl, const char *line)</argsstring>
        <name>lx_preprocessor_cb</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Preprocessor callback. It will be called for each input line. <simplesect kind="return"><para>an error code (0-ok) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="184" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="184" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="lex_8hpp_1abfe84909f3c4a187c0bf9d22f9ef61bf" prot="public" static="no">
        <type>int idaapi</type>
        <definition>typedef int idaapi lx_pragma_cb(void *ud, const char *line)</definition>
        <argsstring>(void *ud, const char *line)</argsstring>
        <name>lx_pragma_cb</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Callback for #pragma directives. <simplesect kind="return"><para>an error code (0-ok) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="190" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="190" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="lex_8hpp_1a8d2e040adda107654a6c5e3544c71c78" prot="public" static="no">
        <type>int idaapi</type>
        <definition>typedef int idaapi lx_warning_cb(void *ud, const char *line)</definition>
        <argsstring>(void *ud, const char *line)</argsstring>
        <name>lx_warning_cb</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Callback for #warning directives. <simplesect kind="return"><para>an error code (0-ok) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="196" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="196" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="lex_8hpp_1a8c223f24bf44d71392d34e99d906f6c1" prot="public" static="no">
        <type>int idaapi</type>
        <definition>typedef int idaapi lx_macro_cb(void *ud, const char *name, const char *body, int nargs, bool isfunc, bool is_new_macro)</definition>
        <argsstring>(void *ud, const char *name, const char *body, int nargs, bool isfunc, bool is_new_macro)</argsstring>
        <name>lx_macro_cb</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Callback for #define directives <simplesect kind="return"><para>an error code (0-ok) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="202" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="202" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="lex_8hpp_1a21010c94d3daa6580be02bba23d7018b" prot="public" static="no">
        <type>int idaapi</type>
        <definition>typedef int idaapi lx_undef_cb(void *ud, const char *name)</definition>
        <argsstring>(void *ud, const char *name)</argsstring>
        <name>lx_undef_cb</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Callback for #undef directives <simplesect kind="return"><para>an error code (0-ok) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="214" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="214" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="group__lx___1ga28e981fa781d4cd520d43011654d5fa8" prot="public" static="no" mutable="no">
        <type>const <ref refid="lex_8hpp_1a89b503fa5c6813a8c60627d2335d49c3" kindref="member">lxtype</ref></type>
        <definition>const lxtype lx_end</definition>
        <argsstring></argsstring>
        <name>lx_end</name>
        <initializer>= 1</initializer>
        <briefdescription>
<para>no more tokens </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="26" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="26" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__lx___1ga10bed2576922f6971c142b806c011087" prot="public" static="no" mutable="no">
        <type>const <ref refid="lex_8hpp_1a89b503fa5c6813a8c60627d2335d49c3" kindref="member">lxtype</ref></type>
        <definition>const lxtype lx_ident</definition>
        <argsstring></argsstring>
        <name>lx_ident</name>
        <initializer>= 2</initializer>
        <briefdescription>
<para>ident </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="27" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="27" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__lx___1ga8e4334ffe5ea9fbf952bc528bc3558c8" prot="public" static="no" mutable="no">
        <type>const <ref refid="lex_8hpp_1a89b503fa5c6813a8c60627d2335d49c3" kindref="member">lxtype</ref></type>
        <definition>const lxtype lx_number</definition>
        <argsstring></argsstring>
        <name>lx_number</name>
        <initializer>= 3</initializer>
        <briefdescription>
<para>long constant </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="28" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="28" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__lx___1ga8ffa2d1bcaf7665a287358ff5759bc24" prot="public" static="no" mutable="no">
        <type>const <ref refid="lex_8hpp_1a89b503fa5c6813a8c60627d2335d49c3" kindref="member">lxtype</ref></type>
        <definition>const lxtype lx_string</definition>
        <argsstring></argsstring>
        <name>lx_string</name>
        <initializer>= 4</initializer>
        <briefdescription>
<para>string constant (token_t.chr != 0 =&gt; unicode string) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="29" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="29" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__lx___1gabee7734ff852fc1014bc0a801418e095" prot="public" static="no" mutable="no">
        <type>const <ref refid="lex_8hpp_1a89b503fa5c6813a8c60627d2335d49c3" kindref="member">lxtype</ref></type>
        <definition>const lxtype lx_char</definition>
        <argsstring></argsstring>
        <name>lx_char</name>
        <initializer>= 5</initializer>
        <briefdescription>
<para>char constant </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="30" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="30" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__lx___1ga95dca21f66831320ddff1c8796a199fe" prot="public" static="no" mutable="no">
        <type>const <ref refid="lex_8hpp_1a89b503fa5c6813a8c60627d2335d49c3" kindref="member">lxtype</ref></type>
        <definition>const lxtype lx_typename</definition>
        <argsstring></argsstring>
        <name>lx_typename</name>
        <initializer>= 6</initializer>
        <briefdescription>
<para>user-defined type </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="31" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="31" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__lx___1gac50abc1f8d4c69467c62cc564d6daf42" prot="public" static="no" mutable="no">
        <type>const <ref refid="lex_8hpp_1a89b503fa5c6813a8c60627d2335d49c3" kindref="member">lxtype</ref></type>
        <definition>const lxtype lx_float</definition>
        <argsstring></argsstring>
        <name>lx_float</name>
        <initializer>= 7</initializer>
        <briefdescription>
<para>IEEE floating point constant. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="32" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="32" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__lx___1ga677b2da507c60eddd4290313b73883a0" prot="public" static="no" mutable="no">
        <type>const <ref refid="lex_8hpp_1a89b503fa5c6813a8c60627d2335d49c3" kindref="member">lxtype</ref></type>
        <definition>const lxtype lx_int64</definition>
        <argsstring></argsstring>
        <name>lx_int64</name>
        <initializer>= 8</initializer>
        <briefdescription>
<para>int64 constant </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="33" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="33" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__lx___1ga9992731b0d95ed4a9c9adf82ac9db347" prot="public" static="no" mutable="no">
        <type>const <ref refid="lex_8hpp_1a89b503fa5c6813a8c60627d2335d49c3" kindref="member">lxtype</ref></type>
        <definition>const lxtype lx_key</definition>
        <argsstring></argsstring>
        <name>lx_key</name>
        <initializer>= 128</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>keywords start. All keys are lx_key + keynum. <linebreak/>
 Two-char separators are: (c1 + (c2 &lt;&lt; 8)). <linebreak/>
 Three-char separators:<itemizedlist>
<listitem><para>&quot;&lt;&lt;=&quot; = (&apos;&lt;&apos; + (&apos;&lt;&apos;&lt;&lt;8)) + &apos;=&apos;</para></listitem><listitem><para>&quot;&gt;&gt;=&quot; = (&apos;&gt;&apos; + (&apos;&gt;&apos;&lt;&lt;8)) + &apos;=&apos; </para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="34" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" bodystart="34" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="lex_8hpp_1a88745b2b81432a7ff622f0c19f3d114b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman lexer_t *ida_export</type>
        <definition>idaman lexer_t* ida_export create_lexer</definition>
        <argsstring>(const char *const *keys, size_t size, void *ud=NULL)</argsstring>
        <name>create_lexer</name>
        <param>
          <type>const char *const *</type>
          <declname>keys</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>ud</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create new lexical analyzer and set its keyword table. If keys==NULL, then set the default C keyword table </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="220" column="1"/>
      </memberdef>
      <memberdef kind="function" id="lex_8hpp_1a78ed5c5c8a801238c5900f886f45ab4f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman void ida_export</type>
        <definition>idaman void ida_export destroy_lexer</definition>
        <argsstring>(lexer_t *lx)</argsstring>
        <name>destroy_lexer</name>
        <param>
          <type>lexer_t *</type>
          <declname>lx</declname>
        </param>
        <briefdescription>
<para>Destroy a lexical analyzer. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="228" column="1"/>
      </memberdef>
      <memberdef kind="function" id="lex_8hpp_1a8758bd4082f74442a7544e1a8a4b9e8d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="pro_8h_1a84c6c720bb5e612c64013a7d4e8acd55" kindref="member">error_t</ref> ida_export</type>
        <definition>idaman error_t ida_export lex_define_macro</definition>
        <argsstring>(lexer_t *lx, const char *macro, const char *body, int nargs=0, bool isfunc=false)</argsstring>
        <name>lex_define_macro</name>
        <param>
          <type>lexer_t *</type>
          <declname>lx</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>macro</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>body</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nargs</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>isfunc</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Define a macro. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="233" column="1"/>
      </memberdef>
      <memberdef kind="function" id="lex_8hpp_1a0cd9ec7908d50fdd4619cd43dd5819dc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman void ida_export</type>
        <definition>idaman void ida_export lex_undefine_macro</definition>
        <argsstring>(lexer_t *lx, const char *macro)</argsstring>
        <name>lex_undefine_macro</name>
        <param>
          <type>lexer_t *</type>
          <declname>lx</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>macro</declname>
        </param>
        <briefdescription>
<para>Undefine a macro. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="242" column="1"/>
      </memberdef>
      <memberdef kind="function" id="lex_8hpp_1ac0f22dce54fbc1a27caaf77325d4f4da" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export lex_set_options</definition>
        <argsstring>(lexer_t *lx, int options)</argsstring>
        <name>lex_set_options</name>
        <param>
          <type>lexer_t *</type>
          <declname>lx</declname>
        </param>
        <param>
          <type>int</type>
          <declname>options</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set lexer options. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>options</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group___l_x_o_p_t__" kindref="compound">Lexer options</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the old options </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="250" column="1"/>
      </memberdef>
      <memberdef kind="function" id="lex_8hpp_1afc84d4c97875841ace0a6e78c55eb4cc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="pro_8h_1a84c6c720bb5e612c64013a7d4e8acd55" kindref="member">error_t</ref> ida_export</type>
        <definition>idaman error_t ida_export lex_get_token</definition>
        <argsstring>(lexer_t *lx, token_t *t)</argsstring>
        <name>lex_get_token</name>
        <param>
          <type>lexer_t *</type>
          <declname>lx</declname>
        </param>
        <param>
          <type><ref refid="structtoken__t" kindref="compound">token_t</ref> *</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Get next token. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="267" column="1"/>
      </memberdef>
      <memberdef kind="function" id="lex_8hpp_1a9f6277f5d349f69305a7e9e9304e0012" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export lex_enum_macros</definition>
        <argsstring>(const lexer_t *lx, int idaapi cb(const char *name, const char *body, int nargs, bool isfunc, void *ud), void *ud=NULL)</argsstring>
        <name>lex_enum_macros</name>
        <param>
          <type>const lexer_t *</type>
          <declname>lx</declname>
        </param>
        <param>
          <type>int idaapi </type>
          <declname>cb</declname>
          <array>const char *name, const char *body, int nargs, bool isfunc, void *ud</array>
        </param>
        <param>
          <type>void *</type>
          <declname>ud</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Enumerate all macros. Do so until &apos;cb&apos; returns non-zero. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="273" column="1"/>
      </memberdef>
      <memberdef kind="function" id="lex_8hpp_1a9d4c383832cc7d60476a8472c6838c01" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman const char *ida_export</type>
        <definition>idaman const char* ida_export lex_print_token</definition>
        <argsstring>(qstring *buf, const token_t *t)</argsstring>
        <name>lex_print_token</name>
        <param>
          <type><ref refid="pro_8h_1a386c10c6aa4340f1d63df85f40454fce" kindref="member">qstring</ref> *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type>const <ref refid="structtoken__t" kindref="compound">token_t</ref> *</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Debug: get text representation of token. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp" line="281" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Tools for parsing C-like input. </para>    </briefdescription>
    <detaileddescription>
<para>Functions in this file use objects of opaque type lexer_t. To create a lexer_t instance, use <ref refid="lex_8hpp_1a88745b2b81432a7ff622f0c19f3d114b" kindref="member">create_lexer()</ref>. </para>    </detaileddescription>
    <location file="obj/x64_linux_gcc_32_opt/idasdk/lex.hpp"/>
  </compounddef>
</doxygen>
