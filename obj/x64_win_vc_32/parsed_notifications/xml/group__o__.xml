<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.12">
  <compounddef id="group__o__" kind="group">
    <compoundname>o_</compoundname>
    <title>Operand types</title>
      <sectiondef kind="var">
      <memberdef kind="variable" id="group__o___1gad68bb114d00bf1541955467158677fa6" prot="public" static="no" mutable="no">
        <type>const <ref refid="ua_8hpp_1aaf9da6ae7e8b201108fc225adf13b4d9" kindref="member">optype_t</ref></type>
        <definition>const optype_t o_void</definition>
        <argsstring></argsstring>
        <name>o_void</name>
        <initializer>=  0</initializer>
        <briefdescription>
<para>No Operand. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" line="80" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" bodystart="80" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__o___1gab490f48c733f3d29c700bb5d70ecc198" prot="public" static="no" mutable="no">
        <type>const <ref refid="ua_8hpp_1aaf9da6ae7e8b201108fc225adf13b4d9" kindref="member">optype_t</ref></type>
        <definition>o_reg</definition>
        <argsstring></argsstring>
        <name>o_reg</name>
        <initializer>=  1</initializer>
        <briefdescription>
<para>General Register (al,ax,es,ds...). </para>        </briefdescription>
        <detaileddescription>
<para>The register number should be stored in <ref refid="classop__t_1a428edf0d3e487135e3d08bd5a65772e4" kindref="member">op_t::reg</ref>. All processor registers, including special registers, can be represented by this operand type. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" line="81" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" bodystart="81" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__o___1gac180aea251826e5e5e484905e116c4cc" prot="public" static="no" mutable="no">
        <type>const <ref refid="ua_8hpp_1aaf9da6ae7e8b201108fc225adf13b4d9" kindref="member">optype_t</ref></type>
        <definition>o_mem</definition>
        <argsstring></argsstring>
        <name>o_mem</name>
        <initializer>=  2</initializer>
        <briefdescription>
<para>Direct Memory Reference (DATA). </para>        </briefdescription>
        <detaileddescription>
<para>A direct memory data reference whose target address is known at compilation time. The target virtual address is stored in <ref refid="classop__t_1acaaeff517df0b7156b4b8521a3900cdc" kindref="member">op_t::addr</ref> and the full address is calculated as to_ea( {cs}, <ref refid="classop__t_1acaaeff517df0b7156b4b8521a3900cdc" kindref="member">op_t::addr</ref> ). For the processors with complex memory organization the final address can be calculated using other segment registers. For flat memories, <ref refid="classop__t_1acaaeff517df0b7156b4b8521a3900cdc" kindref="member">op_t::addr</ref> is the final address and {cs} is usually equal to zero. In any case, the address within the segment should be stored in <ref refid="classop__t_1acaaeff517df0b7156b4b8521a3900cdc" kindref="member">op_t::addr</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" line="82" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" bodystart="82" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__o___1ga622c0d3c3c8af0bed284a02b496ec288" prot="public" static="no" mutable="no">
        <type>const <ref refid="ua_8hpp_1aaf9da6ae7e8b201108fc225adf13b4d9" kindref="member">optype_t</ref></type>
        <definition>o_phrase</definition>
        <argsstring></argsstring>
        <name>o_phrase</name>
        <initializer>=  3</initializer>
        <briefdescription>
<para>Memory Ref [Base Reg + Index Reg]. </para>        </briefdescription>
        <detaileddescription>
<para>A memory reference using register contents. Indexed, register based, and other addressing modes can be represented with the operand type. This addressing mode can not contain immediate values (use <ref refid="group__o___1ga2ae70c4ac00043f25a469a506a6f504f" kindref="member">o_displ</ref> instead). The phrase number should be stored in <ref refid="classop__t_1a583f4819af0dc38593765cd7e6ce17cf" kindref="member">op_t::phrase</ref>. To denote the pre-increment and similar features please use additional operand fields like op_t::specflag... Usually <ref refid="classop__t_1a583f4819af0dc38593765cd7e6ce17cf" kindref="member">op_t::phrase</ref> contains the register number and additional information is stored in op_t::specflags... Please note that this operand type can not contain immediate values (except the scaling coefficients). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" line="83" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" bodystart="83" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__o___1ga2ae70c4ac00043f25a469a506a6f504f" prot="public" static="no" mutable="no">
        <type>const <ref refid="ua_8hpp_1aaf9da6ae7e8b201108fc225adf13b4d9" kindref="member">optype_t</ref></type>
        <definition>o_displ</definition>
        <argsstring></argsstring>
        <name>o_displ</name>
        <initializer>=  4</initializer>
        <briefdescription>
<para>Memory Reg [Base Reg + Index Reg + Displacement]. </para>        </briefdescription>
        <detaileddescription>
<para>A memory reference using register contents with displacement. The displacement should be stored in the <ref refid="classop__t_1acaaeff517df0b7156b4b8521a3900cdc" kindref="member">op_t::addr</ref> field. The rest of information is stored the same way as in <ref refid="group__o___1ga622c0d3c3c8af0bed284a02b496ec288" kindref="member">o_phrase</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" line="84" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" bodystart="84" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__o___1ga85e77bd8098a47465cd8e1193b6e154c" prot="public" static="no" mutable="no">
        <type>const <ref refid="ua_8hpp_1aaf9da6ae7e8b201108fc225adf13b4d9" kindref="member">optype_t</ref></type>
        <definition>o_imm</definition>
        <argsstring></argsstring>
        <name>o_imm</name>
        <initializer>=  5</initializer>
        <briefdescription>
<para>Immediate Value. </para>        </briefdescription>
        <detaileddescription>
<para>Any operand consisting of only a number is represented by this operand type. The value should be stored in <ref refid="classop__t_1a6baa38b521c143a794640d82df109ae2" kindref="member">op_t::value</ref>. You may sign extend short (1-2 byte) values. In any case don&apos;t forget to specify <ref refid="classop__t_1a9d0ea64a2929fc998bca6cebd1b91c09" kindref="member">op_t::dtype</ref> (should be set for all operand types). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" line="85" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" bodystart="85" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__o___1gac4a43a41f9a3a31b7bb6193e6d3cc447" prot="public" static="no" mutable="no">
        <type>const <ref refid="ua_8hpp_1aaf9da6ae7e8b201108fc225adf13b4d9" kindref="member">optype_t</ref></type>
        <definition>o_far</definition>
        <argsstring></argsstring>
        <name>o_far</name>
        <initializer>=  6</initializer>
        <briefdescription>
<para>Immediate Far Address (CODE). </para>        </briefdescription>
        <detaileddescription>
<para>If the current processor has a special addressing mode for inter-segment references, then this operand type should be used instead of <ref refid="group__o___1ga05209644e1ec11a2b0d96809bb60d6d8" kindref="member">o_near</ref>. If you want, you may use <ref refid="group___p_r___1ga884adc60ef0e7236192b78ec4f900f0e" kindref="member">PR_CHK_XREF</ref> in {flag} to disable inter-segment calls if <ref refid="group__o___1ga05209644e1ec11a2b0d96809bb60d6d8" kindref="member">o_near</ref> operand type is used. Currently only IBM PC uses this flag. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" line="86" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" bodystart="86" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__o___1ga05209644e1ec11a2b0d96809bb60d6d8" prot="public" static="no" mutable="no">
        <type>const <ref refid="ua_8hpp_1aaf9da6ae7e8b201108fc225adf13b4d9" kindref="member">optype_t</ref></type>
        <definition>o_near</definition>
        <argsstring></argsstring>
        <name>o_near</name>
        <initializer>=  7</initializer>
        <briefdescription>
<para>Immediate Near Address (CODE). </para>        </briefdescription>
        <detaileddescription>
<para>A direct memory code reference whose target address is known at the compilation time. The target virtual address is stored in <ref refid="classop__t_1acaaeff517df0b7156b4b8521a3900cdc" kindref="member">op_t::addr</ref> and the final address is always to_ea({cs}, <ref refid="classop__t_1acaaeff517df0b7156b4b8521a3900cdc" kindref="member">op_t::addr</ref>). Usually this operand type is used for the branches and calls whose target address is known. If the current processor has 2 different types of references for inter-segment and intra-segment references, then this should be used only for intra-segment references.</para><para>If the above operand types do not cover all possible addressing modes, then use o_idpspec... operand types. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" line="87" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" bodystart="87" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__o___1ga93c65fe52df27c2cf286579834e89f1c" prot="public" static="no" mutable="no">
        <type>const <ref refid="ua_8hpp_1aaf9da6ae7e8b201108fc225adf13b4d9" kindref="member">optype_t</ref></type>
        <definition>const optype_t o_idpspec0</definition>
        <argsstring></argsstring>
        <name>o_idpspec0</name>
        <initializer>=  8</initializer>
        <briefdescription>
<para>processor specific type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" line="88" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" bodystart="88" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__o___1ga28544d70e5118d18bc443b1551bfb0d4" prot="public" static="no" mutable="no">
        <type>const <ref refid="ua_8hpp_1aaf9da6ae7e8b201108fc225adf13b4d9" kindref="member">optype_t</ref></type>
        <definition>const optype_t o_idpspec1</definition>
        <argsstring></argsstring>
        <name>o_idpspec1</name>
        <initializer>=  9</initializer>
        <briefdescription>
<para>processor specific type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" line="89" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" bodystart="89" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__o___1ga6aeffb56e320e7815d2fa9d2788f7512" prot="public" static="no" mutable="no">
        <type>const <ref refid="ua_8hpp_1aaf9da6ae7e8b201108fc225adf13b4d9" kindref="member">optype_t</ref></type>
        <definition>const optype_t o_idpspec2</definition>
        <argsstring></argsstring>
        <name>o_idpspec2</name>
        <initializer>= 10</initializer>
        <briefdescription>
<para>processor specific type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" line="90" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" bodystart="90" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__o___1ga38b52acb452efd50718bcc910bc9dce7" prot="public" static="no" mutable="no">
        <type>const <ref refid="ua_8hpp_1aaf9da6ae7e8b201108fc225adf13b4d9" kindref="member">optype_t</ref></type>
        <definition>const optype_t o_idpspec3</definition>
        <argsstring></argsstring>
        <name>o_idpspec3</name>
        <initializer>= 11</initializer>
        <briefdescription>
<para>processor specific type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" line="91" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" bodystart="91" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__o___1ga8ea529384422fe137b199e9d849182c0" prot="public" static="no" mutable="no">
        <type>const <ref refid="ua_8hpp_1aaf9da6ae7e8b201108fc225adf13b4d9" kindref="member">optype_t</ref></type>
        <definition>const optype_t o_idpspec4</definition>
        <argsstring></argsstring>
        <name>o_idpspec4</name>
        <initializer>= 12</initializer>
        <briefdescription>
<para>processor specific type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" line="92" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" bodystart="92" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="group__o___1ga610f9018ae82af4151f4270fca95be68" prot="public" static="no" mutable="no">
        <type>const <ref refid="ua_8hpp_1aaf9da6ae7e8b201108fc225adf13b4d9" kindref="member">optype_t</ref></type>
        <definition>const optype_t o_idpspec5</definition>
        <argsstring></argsstring>
        <name>o_idpspec5</name>
        <initializer>= 13</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>processor specific type. (there can be more processor specific types) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" line="93" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/ua.hpp" bodystart="93" bodyend="-1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Various types of instruction operands. The kernel already knows about some operand types and associates them with fields in <ref refid="classop__t" kindref="compound">op_t</ref>.</para><para>IDA also allows you define processor specific operand types (o_idpspec...). You are free to give any meaning to these types. We suggest you to create a #define to use mnemonic names. However, don&apos;t forget that the kernel will know nothing about operands of those types. You may use any additional fields of <ref refid="classop__t" kindref="compound">op_t</ref> to store processor specific operand information. </para>    </detaileddescription>
  </compounddef>
</doxygen>
