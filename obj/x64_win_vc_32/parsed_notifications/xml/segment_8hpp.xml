<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.12">
  <compounddef id="segment_8hpp" kind="file" language="C++">
    <compoundname>segment.hpp</compoundname>
    <includes refid="ida_8hpp" local="no">ida.hpp</includes>
    <includes refid="range_8hpp" local="no">range.hpp</includes>
    <includedby refid="offset_8hpp" local="no">obj/x64_linux_gcc_32_opt/idasdk/offset.hpp</includedby>
    <includedby refid="fixup_8hpp" local="no">obj/x64_linux_gcc_32_opt/idasdk/fixup.hpp</includedby>
    <includedby refid="idp_8hpp" local="no">obj/x64_linux_gcc_32_opt/idasdk/idp.hpp</includedby>
    <incdepgraph>
      <node id="1332">
        <label>sys/stat.h</label>
      </node>
      <node id="1316">
        <label>stdarg.h</label>
      </node>
      <node id="1319">
        <label>assert.h</label>
      </node>
      <node id="1313">
        <label>ida.hpp</label>
        <link refid="ida_8hpp"/>
        <childnode refid="1314" relation="include">
        </childnode>
        <childnode refid="1334" relation="include">
        </childnode>
      </node>
      <node id="1315">
        <label>stdlib.h</label>
      </node>
      <node id="1327">
        <label>io.h</label>
      </node>
      <node id="1330">
        <label>fcntl.h</label>
      </node>
      <node id="1333">
        <label>llong.hpp</label>
        <link refid="llong_8hpp_source"/>
      </node>
      <node id="1325">
        <label>malloc.h</label>
      </node>
      <node id="1324">
        <label>string</label>
      </node>
      <node id="1329">
        <label>map</label>
      </node>
      <node id="1328">
        <label>direct.h</label>
      </node>
      <node id="1317">
        <label>stddef.h</label>
      </node>
      <node id="1320">
        <label>limits.h</label>
      </node>
      <node id="1331">
        <label>sys/types.h</label>
      </node>
      <node id="1326">
        <label>string.h</label>
      </node>
      <node id="1323">
        <label>new</label>
      </node>
      <node id="1314">
        <label>pro.h</label>
        <link refid="pro_8h"/>
        <childnode refid="1315" relation="include">
        </childnode>
        <childnode refid="1316" relation="include">
        </childnode>
        <childnode refid="1317" relation="include">
        </childnode>
        <childnode refid="1318" relation="include">
        </childnode>
        <childnode refid="1319" relation="include">
        </childnode>
        <childnode refid="1320" relation="include">
        </childnode>
        <childnode refid="1321" relation="include">
        </childnode>
        <childnode refid="1322" relation="include">
        </childnode>
        <childnode refid="1323" relation="include">
        </childnode>
        <childnode refid="1324" relation="include">
        </childnode>
        <childnode refid="1325" relation="include">
        </childnode>
        <childnode refid="1326" relation="include">
        </childnode>
        <childnode refid="1327" relation="include">
        </childnode>
        <childnode refid="1328" relation="include">
        </childnode>
        <childnode refid="1329" relation="include">
        </childnode>
        <childnode refid="1330" relation="include">
        </childnode>
        <childnode refid="1331" relation="include">
        </childnode>
        <childnode refid="1332" relation="include">
        </childnode>
        <childnode refid="1333" relation="include">
        </childnode>
      </node>
      <node id="1312">
        <label>obj/x64_linux_gcc_32_opt/idasdk/segment.hpp</label>
        <link refid="segment_8hpp"/>
        <childnode refid="1313" relation="include">
        </childnode>
        <childnode refid="1334" relation="include">
        </childnode>
      </node>
      <node id="1322">
        <label>time.h</label>
      </node>
      <node id="1321">
        <label>ctype.h</label>
      </node>
      <node id="1334">
        <label>range.hpp</label>
        <link refid="range_8hpp"/>
      </node>
      <node id="1318">
        <label>stdio.h</label>
      </node>
    </incdepgraph>
    <invincdepgraph>
      <node id="1344">
        <label>obj/x64_linux_gcc_32_opt/idasdk/intel.hpp</label>
        <link refid="intel_8hpp_source"/>
      </node>
      <node id="1347">
        <label>obj/x64_linux_gcc_32_opt/idasdk/ida_highlighter.hpp</label>
        <link refid="ida__highlighter_8hpp_source"/>
      </node>
      <node id="1338">
        <label>obj/x64_linux_gcc_32_opt/idasdk/idp.hpp</label>
        <link refid="idp_8hpp"/>
        <childnode refid="1339" relation="include">
        </childnode>
        <childnode refid="1340" relation="include">
        </childnode>
        <childnode refid="1341" relation="include">
        </childnode>
        <childnode refid="1343" relation="include">
        </childnode>
        <childnode refid="1345" relation="include">
        </childnode>
        <childnode refid="1346" relation="include">
        </childnode>
      </node>
      <node id="1339">
        <label>obj/x64_linux_gcc_32_opt/idasdk/dbg.hpp</label>
        <link refid="dbg_8hpp"/>
      </node>
      <node id="1345">
        <label>obj/x64_linux_gcc_32_opt/idasdk/graph.hpp</label>
        <link refid="graph_8hpp"/>
      </node>
      <node id="1348">
        <label>obj/x64_linux_gcc_32_opt/idasdk/tstfeat.hpp</label>
        <link refid="tstfeat_8hpp_source"/>
      </node>
      <node id="1346">
        <label>obj/x64_linux_gcc_32_opt/idasdk/expr.hpp</label>
        <link refid="expr_8hpp"/>
        <childnode refid="1347" relation="include">
        </childnode>
        <childnode refid="1348" relation="include">
        </childnode>
      </node>
      <node id="1337">
        <label>obj/x64_linux_gcc_32_opt/idasdk/fixup.hpp</label>
        <link refid="fixup_8hpp"/>
      </node>
      <node id="1340">
        <label>obj/x64_linux_gcc_32_opt/idasdk/frame.hpp</label>
        <link refid="frame_8hpp"/>
      </node>
      <node id="1335">
        <label>obj/x64_linux_gcc_32_opt/idasdk/segment.hpp</label>
        <link refid="segment_8hpp"/>
        <childnode refid="1336" relation="include">
        </childnode>
        <childnode refid="1337" relation="include">
        </childnode>
        <childnode refid="1338" relation="include">
        </childnode>
      </node>
      <node id="1336">
        <label>obj/x64_linux_gcc_32_opt/idasdk/offset.hpp</label>
        <link refid="offset_8hpp"/>
      </node>
      <node id="1341">
        <label>obj/x64_linux_gcc_32_opt/idasdk/typeinf.hpp</label>
        <link refid="typeinf_8hpp"/>
        <childnode refid="1342" relation="include">
        </childnode>
        <childnode refid="1343" relation="include">
        </childnode>
        <childnode refid="1344" relation="include">
        </childnode>
      </node>
      <node id="1343">
        <label>obj/x64_linux_gcc_32_opt/idasdk/hexrays.hpp</label>
        <link refid="hexrays_8hpp_source"/>
      </node>
      <node id="1342">
        <label>obj/x64_linux_gcc_32_opt/idasdk/lumina.hpp</label>
        <link refid="lumina_8hpp_source"/>
      </node>
    </invincdepgraph>
    <innerclass refid="classsegment__t" prot="public">segment_t</innerclass>
    <innerclass refid="classlock__segment" prot="public">lock_segment</innerclass>
      <sectiondef kind="define">
      <memberdef kind="define" id="segment_8hpp_1a2cc79101b0a36f26dae427dec04047e7" prot="public" static="no">
        <name>SREG_NUM</name>
        <initializer>16</initializer>
        <briefdescription>
<para>Maximum number of segment registers is 16 (see <ref refid="segregs_8hpp" kindref="compound">segregs.hpp</ref>) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="56" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="56" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sa___1ga4697d125cb311ad2487ddd63683bb9bd" prot="public" static="no">
        <name>saAbs</name>
        <initializer>0</initializer>
        <briefdescription>
<para>Absolute segment. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="85" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="85" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sa___1ga0aecfd12e64028f0712d6cad0403b66b" prot="public" static="no">
        <name>saRelByte</name>
        <initializer>1</initializer>
        <briefdescription>
<para>Relocatable, byte aligned. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="86" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="86" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sa___1gadec2f7b0d3cc73c432b3cd515630edce" prot="public" static="no">
        <name>saRelWord</name>
        <initializer>2</initializer>
        <briefdescription>
<para>Relocatable, word (2-byte) aligned. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="87" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="87" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sa___1ga034b61cd4186cc800c9cccbf4ca579fc" prot="public" static="no">
        <name>saRelPara</name>
        <initializer>3</initializer>
        <briefdescription>
<para>Relocatable, paragraph (16-byte) aligned. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="88" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="88" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sa___1ga1d051b1877d03b0b447cdf9ba36fb53d" prot="public" static="no">
        <name>saRelPage</name>
        <initializer>4</initializer>
        <briefdescription>
<para>Relocatable, aligned on 256-byte boundary. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="89" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="89" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sa___1gaff7775baddfc01bf6179be9983462f10" prot="public" static="no">
        <name>saRelDble</name>
        <initializer>5</initializer>
        <briefdescription>
<para>boundary. </para>        </briefdescription>
        <detaileddescription>
<para>Relocatable, aligned on a double word (4-byte) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="90" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="90" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sa___1ga765c3364a1877c3a87d83e40322ba14f" prot="public" static="no">
        <name>saRel4K</name>
        <initializer>6</initializer>
        <briefdescription>
<para>alignment. It is not supported by LINK. </para>        </briefdescription>
        <detaileddescription>
<para>This value is used by the PharLap OMF for page (4K) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="92" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="92" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sa___1ga98d02d37653e067648515434ef024b7e" prot="public" static="no">
        <name>saGroup</name>
        <initializer>7</initializer>
        <briefdescription>
<para>Segment group. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="94" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="94" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sa___1ga6ffa6a6277b95550e88745d2b0756613" prot="public" static="no">
        <name>saRel32Bytes</name>
        <initializer>8</initializer>
        <briefdescription>
<para>32 bytes </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="95" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="95" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sa___1ga6663af84554de00ae36835ef061e5614" prot="public" static="no">
        <name>saRel64Bytes</name>
        <initializer>9</initializer>
        <briefdescription>
<para>64 bytes </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="96" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="96" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sa___1ga44e590d43f0a17bff91318c070406c46" prot="public" static="no">
        <name>saRelQword</name>
        <initializer>10</initializer>
        <briefdescription>
<para>8 bytes </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="97" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="97" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sa___1ga9328a9b21edfc4da676d29b2ce255b7e" prot="public" static="no">
        <name>saRel128Bytes</name>
        <initializer>11</initializer>
        <briefdescription>
<para>128 bytes </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="98" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="98" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sa___1gae415d0f706c767f99234fe6c8d970d2b" prot="public" static="no">
        <name>saRel512Bytes</name>
        <initializer>12</initializer>
        <briefdescription>
<para>512 bytes </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="99" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="99" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sa___1ga4d5213ae8be94b40698c7c375c1f16c4" prot="public" static="no">
        <name>saRel1024Bytes</name>
        <initializer>13</initializer>
        <briefdescription>
<para>1024 bytes </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="100" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="100" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sa___1gab3bcf5d7907785f4fae15af499fd91b0" prot="public" static="no">
        <name>saRel2048Bytes</name>
        <initializer>14</initializer>
        <briefdescription>
<para>2048 bytes </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="101" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="101" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sa___1ga40112e1c1deceb7107a877e6b5eddf9f" prot="public" static="no">
        <name>saRel_MAX_ALIGN_CODE</name>
        <initializer><ref refid="group__sa___1gab3bcf5d7907785f4fae15af499fd91b0" kindref="member">saRel2048Bytes</ref></initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="102" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="102" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sc___1ga38ed1a87ad2b2dd47313a29e07811dc4" prot="public" static="no">
        <name>scPriv</name>
        <initializer>0</initializer>
        <briefdescription>
<para>segment. </para>        </briefdescription>
        <detaileddescription>
<para>Private. Do not combine with any other program </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="110" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="110" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sc___1ga018cbd3b983fd7b03dccaf9817397b8c" prot="public" static="no">
        <name>scGroup</name>
        <initializer>1</initializer>
        <briefdescription>
<para>Segment group. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="112" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="112" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sc___1gaca4d1acba99d1b265076d884ba2ec250" prot="public" static="no">
        <name>scPub</name>
        <initializer>2</initializer>
        <briefdescription>
<para>the alignment requirement. </para>        </briefdescription>
        <detaileddescription>
<para>Public. Combine by appending at an offset that meets </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="113" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="113" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sc___1gab79af580de4cec4a9b836c070cba9de2" prot="public" static="no">
        <name>scPub2</name>
        <initializer>4</initializer>
        <briefdescription>
<para>As defined by Microsoft, same as C=2 (public). </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="115" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="115" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sc___1gaeee8fe69cf688dc99b8baa848e3bec54" prot="public" static="no">
        <name>scStack</name>
        <initializer>5</initializer>
        <briefdescription>
<para>byte alignment. </para>        </briefdescription>
        <detaileddescription>
<para>Stack. Combine as for C=2. This combine type forces </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="116" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="116" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sc___1ga433bb6d9f37f3cfb6139534aedfac6e6" prot="public" static="no">
        <name>scCommon</name>
        <initializer>6</initializer>
        <briefdescription>
<para>Common. Combine by overlay using maximum size. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="118" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="118" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sc___1ga823a88802af7bc72222190bbd5ff26e1" prot="public" static="no">
        <name>scPub3</name>
        <initializer>7</initializer>
        <briefdescription>
<para>As defined by Microsoft, same as C=2 (public). </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="119" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="119" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__sc___1ga627f8aa059efe19465b30eb56e2769d1" prot="public" static="no">
        <name>sc_MAX_COMB_CODE</name>
        <initializer><ref refid="group__sc___1ga823a88802af7bc72222190bbd5ff26e1" kindref="member">scPub3</ref></initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="120" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="120" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g_p_e_r_m___1gac1f99c160c8494f887194ac29968ae6d" prot="public" static="no">
        <name>SEGPERM_EXEC</name>
        <initializer>1</initializer>
        <briefdescription>
<para>Execute. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="128" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="128" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g_p_e_r_m___1gacf28b814d1aa6a9aac4ec6bf170bc6ff" prot="public" static="no">
        <name>SEGPERM_WRITE</name>
        <initializer>2</initializer>
        <briefdescription>
<para>Write. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="129" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="129" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g_p_e_r_m___1ga4b490152c7fc5f7ff4a9183a8c917e6a" prot="public" static="no">
        <name>SEGPERM_READ</name>
        <initializer>4</initializer>
        <briefdescription>
<para>Read. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="130" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="130" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g_p_e_r_m___1ga9dc6d67d0a3d758fc7b0b34d83429bf9" prot="public" static="no">
        <name>SEGPERM_MAXVAL</name>
        <initializer>(<ref refid="group___s_e_g_p_e_r_m___1gac1f99c160c8494f887194ac29968ae6d" kindref="member">SEGPERM_EXEC</ref> + <ref refid="group___s_e_g_p_e_r_m___1gacf28b814d1aa6a9aac4ec6bf170bc6ff" kindref="member">SEGPERM_WRITE</ref> + <ref refid="group___s_e_g_p_e_r_m___1ga4b490152c7fc5f7ff4a9183a8c917e6a" kindref="member">SEGPERM_READ</ref>)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="131" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="131" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="segment_8hpp_1a4007e0fda12fadafd3865883e928095b" prot="public" static="no">
        <name>SEG_MAX_BITNESS_CODE</name>
        <initializer>2</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="138" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="138" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_f_l___1ga76758a64e75c56b04c528c84d3b70efe" prot="public" static="no">
        <name>SFL_COMORG</name>
        <initializer>0x01</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>IDP dependent field (IBM PC: if set, ORG directive is not commented out) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="157" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="157" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_f_l___1ga33bd87d84e584f97b279e193f0ae958a" prot="public" static="no">
        <name>SFL_OBOK</name>
        <initializer>0x02</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Orgbase is present? (IDP dependent field) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="169" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="169" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_f_l___1gac31257ddd90ad0acab343cebc28c2233" prot="public" static="no">
        <name>SFL_HIDDEN</name>
        <initializer>0x04</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Is the segment hidden? </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="181" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="181" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_f_l___1ga663d197c2dead5d7c02d36afa81b6738" prot="public" static="no">
        <name>SFL_DEBUG</name>
        <initializer>0x08</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Is the segment created for the debugger?. Such segments are temporary and do not have permanent flags. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="193" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="193" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_f_l___1gac89841edaa1830e41e109c416948c96d" prot="public" static="no">
        <name>SFL_LOADER</name>
        <initializer>0x10</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Is the segment created by the loader? </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="204" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="204" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_f_l___1ga5897753448a6c769538ed3890b9b8129" prot="public" static="no">
        <name>SFL_HIDETYPE</name>
        <initializer>0x20</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Hide segment type (do not print it in the listing) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="215" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="215" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_f_l___1gac3bc49be172d44aad904ac8ab8aa8c3c" prot="public" static="no">
        <name>SFL_HEADER</name>
        <initializer>0x40</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Header segment (do not create offsets to it in the disassembly) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="226" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="226" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g___1ga8743c2828565f269e2e28c131abdc4ff" prot="public" static="no">
        <name>SEG_NORM</name>
        <initializer>0</initializer>
        <briefdescription>
<para>unknown type, no assumptions </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="263" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="263" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g___1ga5c9bbede59653b945dacc70598306289" prot="public" static="no">
        <name>SEG_XTRN</name>
        <initializer>1</initializer>
        <briefdescription>
<para>no instructions are allowed </para>        </briefdescription>
        <detaileddescription>
<para><itemizedlist>
<listitem><para>segment with &apos;extern&apos; definitions. </para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="264" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="264" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g___1gacfc10101b1288e858b747c0a9c329226" prot="public" static="no">
        <name>SEG_CODE</name>
        <initializer>2</initializer>
        <briefdescription>
<para>code segment </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="266" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="266" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g___1ga9f583dca1a7fef2948458048c70b2f1c" prot="public" static="no">
        <name>SEG_DATA</name>
        <initializer>3</initializer>
        <briefdescription>
<para>data segment </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="267" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="267" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g___1gaa22448536108607769405d6ca1f69034" prot="public" static="no">
        <name>SEG_IMP</name>
        <initializer>4</initializer>
        <briefdescription>
<para>java: implementation segment </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="268" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="268" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g___1gab3bd0f97c65dd59b10ea76b16d444784" prot="public" static="no">
        <name>SEG_GRP</name>
        <initializer>6</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><itemizedlist>
<listitem><para>group of segments </para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="269" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="269" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g___1ga594f82f31d1ed7189ad21c3af3279269" prot="public" static="no">
        <name>SEG_NULL</name>
        <initializer>7</initializer>
        <briefdescription>
<para>zero-length segment </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="270" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="270" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g___1ga344b3516eb098ebe8ce00e193af53270" prot="public" static="no">
        <name>SEG_UNDF</name>
        <initializer>8</initializer>
        <briefdescription>
<para>undefined segment type (not used) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="271" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="271" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g___1ga0e7d8517210b3c56679eca1111e4c0fc" prot="public" static="no">
        <name>SEG_BSS</name>
        <initializer>9</initializer>
        <briefdescription>
<para>uninitialized segment </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="272" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="272" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g___1ga5c130d299e48ff537068e03e8ae23d71" prot="public" static="no">
        <name>SEG_ABSSYM</name>
        <initializer>10</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><itemizedlist>
<listitem><para>segment with definitions of absolute symbols </para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="273" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="273" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g___1ga39a39aa78e00ea21899571a2b636976e" prot="public" static="no">
        <name>SEG_COMM</name>
        <initializer>11</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><itemizedlist>
<listitem><para>segment with communal definitions </para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="274" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="274" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g___1ga661e744128725accf12f76a91ac82c41" prot="public" static="no">
        <name>SEG_IMEM</name>
        <initializer>12</initializer>
        <briefdescription>
<para>internal processor memory &amp; sfr (8051) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="275" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="275" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g___1gad44f4f206e7051e581de00a394a76282" prot="public" static="no">
        <name>SEG_MAX_SEGTYPE_CODE</name>
        <initializer><ref refid="group___s_e_g___1ga661e744128725accf12f76a91ac82c41" kindref="member">SEG_IMEM</ref></initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="276" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="276" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___a_d_d_s_e_g___1ga94dc2da752d9e80fad8caf501c5489d9" prot="public" static="no">
        <name>ADDSEG_NOSREG</name>
        <initializer>0x0001</initializer>
        <briefdescription>
<para>(undefine all default segment registers) </para>        </briefdescription>
        <detaileddescription>
<para>set all default segment register values to <ref refid="pro_8h_1a893ddf307fae0a3bbca667ee917cddc7" kindref="member">BADSEL</ref> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="533" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="533" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___a_d_d_s_e_g___1gaef2ab311485a9bc2b09d2a8f03a647a3" prot="public" static="no">
        <name>ADDSEG_OR_DIE</name>
        <initializer>0x0002</initializer>
        <briefdescription>
<para><ref refid="pro_8h_1a53e88c62090838e19cb5ee945d7ab8f7" kindref="member">qexit()</ref> if can&apos;t add a segment </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="535" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="535" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___a_d_d_s_e_g___1ga5d6e405b6fb6faf18cc2c064ba592401" prot="public" static="no">
        <name>ADDSEG_NOTRUNC</name>
        <initializer>0x0004</initializer>
        <briefdescription>
<para>destroy/truncate old segments instead. </para>        </briefdescription>
        <detaileddescription>
<para>don&apos;t truncate the new segment at the beginning of the next segment if they overlap. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="536" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="536" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___a_d_d_s_e_g___1gaee75ca1c810be184ef12055d637e5d2f" prot="public" static="no">
        <name>ADDSEG_QUIET</name>
        <initializer>0x0008</initializer>
        <briefdescription>
<para>silent mode, no &quot;Adding segment...&quot; in the messages window </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="538" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="538" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___a_d_d_s_e_g___1gad1996026d4ee36dd29aeee83535c845d" prot="public" static="no">
        <name>ADDSEG_FILLGAP</name>
        <initializer>0x0010</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>fill gap between new segment and previous one. i.e. if such a gap exists, and this gap is less than 64K, then fill the gap by extending the previous segment and adding .align directive to it. This way we avoid gaps between segments. too many gaps lead to a virtual array failure. it can not hold more than ~1000 gaps. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="539" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="539" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___a_d_d_s_e_g___1gaadc4d5db47a493aca1f9a9d3725d7651" prot="public" static="no">
        <name>ADDSEG_SPARSE</name>
        <initializer>0x0020</initializer>
        <briefdescription>
<para>use sparse storage method for the new segment </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="546" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="546" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___a_d_d_s_e_g___1gaa193b0b6eb2b21ea8b440de9fcad9e78" prot="public" static="no">
        <name>ADDSEG_NOAA</name>
        <initializer>0x0040</initializer>
        <briefdescription>
<para>do not mark new segment for auto-analysis </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="547" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="547" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___a_d_d_s_e_g___1ga11530c497d1630b0f2aeae908b038d0c" prot="public" static="no">
        <name>ADDSEG_IDBENC</name>
        <initializer>0x0080</initializer>
        <briefdescription>
<para>non-ASCII bytes will be decoded accordingly </para>        </briefdescription>
        <detaileddescription>
<para>&apos;name&apos; and &apos;sclass&apos; are given in the IDB encoding; </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="548" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="548" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g_m_o_d___1ga9305d855a66ea14f3efc11dbba83236a" prot="public" static="no">
        <name>SEGMOD_KILL</name>
        <initializer>0x0001</initializer>
        <briefdescription>
<para>disable addresses if segment gets shrinked or deleted </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="610" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="610" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g_m_o_d___1ga8c13b0da46d0f56b4a85158c48fe95eb" prot="public" static="no">
        <name>SEGMOD_KEEP</name>
        <initializer>0x0002</initializer>
        <briefdescription>
<para>keep information (code &amp; data, etc) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="611" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="611" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g_m_o_d___1ga3c6914d8e96834d9f75c3271addef56d" prot="public" static="no">
        <name>SEGMOD_SILENT</name>
        <initializer>0x0004</initializer>
        <briefdescription>
<para>be silent </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="612" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="612" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g_m_o_d___1gad1498b4080390eb46f9f905c4e67437a" prot="public" static="no">
        <name>SEGMOD_KEEP0</name>
        <initializer>0x0008</initializer>
        <briefdescription>
<para>flag for internal use, don&apos;t set </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="613" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="613" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g_m_o_d___1ga6657a780db914630b7a156aac2549d88" prot="public" static="no">
        <name>SEGMOD_KEEPSEL</name>
        <initializer>0x0010</initializer>
        <briefdescription>
<para>do not try to delete unused selector </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="614" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="614" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g_m_o_d___1gaa4d8f0e4d83b261bcc5de1600199230b" prot="public" static="no">
        <name>SEGMOD_NOMOVE</name>
        <initializer>0x0020</initializer>
        <briefdescription>
<para>(for <ref refid="group__seg__man_1gaffcd6c25a6d3bfc4bafeb786db81ec79" kindref="member">set_segm_start()</ref>) </para>        </briefdescription>
        <detaileddescription>
<para>don&apos;t move info from the start of segment to the new start address </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="615" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="615" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___s_e_g_m_o_d___1ga182c0e6bd2cba7e46f360464ffe38276" prot="public" static="no">
        <name>SEGMOD_SPARSE</name>
        <initializer>0x0040</initializer>
        <briefdescription>
<para>(for <ref refid="group__seg__man_1gaffcd6c25a6d3bfc4bafeb786db81ec79" kindref="member">set_segm_start()</ref>, <ref refid="group__seg__man_1gaadde01303718a6cde673dca12ffac9d7" kindref="member">set_segm_end()</ref>) </para>        </briefdescription>
        <detaileddescription>
<para>use sparse storage if extending the segment </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="617" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="617" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___m_s_f___1ga74cba55c4f444b0a4c51653e1f5877aa" prot="public" static="no">
        <name>MSF_SILENT</name>
        <initializer>0x0001</initializer>
        <briefdescription>
<para>don&apos;t display a &quot;please wait&quot; box on the screen </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="743" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="743" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___m_s_f___1ga95498cd45f2b9b85103fcac3c9a1df32" prot="public" static="no">
        <name>MSF_NOFIX</name>
        <initializer>0x0002</initializer>
        <briefdescription>
<para>don&apos;t call the loader to fix relocations </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="744" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="744" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___m_s_f___1ga6375a028748826abee3c02826f37e8af" prot="public" static="no">
        <name>MSF_LDKEEP</name>
        <initializer>0x0004</initializer>
        <briefdescription>
<para>keep the loader in the memory (optimization) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="745" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="745" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___m_s_f___1ga89693134e1c29045c8c9a1b77f106813" prot="public" static="no">
        <name>MSF_FIXONCE</name>
        <initializer>0x0008</initializer>
        <briefdescription>
<para>valid for <ref refid="group__seg__man_1gaa5f20d1b84b6cbccb5a4b173f26e3599" kindref="member">rebase_program()</ref>. see <ref refid="structloader__t_1a7a329922101a4e28a2b7018e565a3b5d" kindref="member">loader_t::move_segm</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>call loader only once with the special calling method. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="746" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="746" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___m_s_f___1ga28e685194c0e3c2d88cf814b6aa5a766" prot="public" static="no">
        <name>MFS_NETMAP</name>
        <initializer>0x0010</initializer>
        <briefdescription>
<para>valid for <ref refid="group__seg__man_1gaa5f20d1b84b6cbccb5a4b173f26e3599" kindref="member">rebase_program()</ref> </para>        </briefdescription>
        <detaileddescription>
<para>change inf.netdelta if possible (this is faster) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="748" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="748" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___m_s_f___1ga2c8b83720e61ef7c1cd29ea477ace306" prot="public" static="no">
        <name>MSF_PRIORITY</name>
        <initializer>0x0020</initializer>
        <briefdescription>
<para>valid for <ref refid="group__seg__man_1gab3c11fbdf0ac345cb618b8b0ad3ef04c" kindref="member">move_segm()</ref> </para>        </briefdescription>
        <detaileddescription>
<para>loader segments will overwrite any existing debugger segments when moved. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="750" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="750" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___m_o_v_e___s_e_g_m___1gafe6cdfae813a03b8fa0e5e6b7b741bc9" prot="public" static="no">
        <name>MOVE_SEGM_OK</name>
        <initializer>0</initializer>
        <briefdescription>
<para>all ok </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="757" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="757" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___m_o_v_e___s_e_g_m___1gaf67ba30b9748523baac6cc98f15a4e8a" prot="public" static="no">
        <name>MOVE_SEGM_PARAM</name>
        <initializer>-1</initializer>
        <briefdescription>
<para>The specified segment does not exist. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="758" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="758" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___m_o_v_e___s_e_g_m___1ga6c84213f5718f76655993ff37e88f823" prot="public" static="no">
        <name>MOVE_SEGM_ROOM</name>
        <initializer>-2</initializer>
        <briefdescription>
<para>Not enough free room at the target address. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="759" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="759" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___m_o_v_e___s_e_g_m___1ga7136bdca237152b0e8e8f21924df5091" prot="public" static="no">
        <name>MOVE_SEGM_IDP</name>
        <initializer>-3</initializer>
        <briefdescription>
<para>IDP module forbids moving the segment. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="760" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="760" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___m_o_v_e___s_e_g_m___1ga8e5d1b0d5d3a9c146068d9ac40ef2bdc" prot="public" static="no">
        <name>MOVE_SEGM_CHUNK</name>
        <initializer>-4</initializer>
        <briefdescription>
<para>Too many chunks are defined, can&apos;t move. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="761" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="761" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___m_o_v_e___s_e_g_m___1gaf38f9db740d57b0d0ee1aa461c8d3867" prot="public" static="no">
        <name>MOVE_SEGM_LOADER</name>
        <initializer>-5</initializer>
        <briefdescription>
<para>The segment has been moved but the loader complained. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="762" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="762" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___m_o_v_e___s_e_g_m___1gaa99197427fa79a0a4e204e1cc78eae43" prot="public" static="no">
        <name>MOVE_SEGM_ODD</name>
        <initializer>-6</initializer>
        <briefdescription>
<para>Can not move segments by an odd number of bytes. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="763" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="763" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___m_o_v_e___s_e_g_m___1ga65b42e516b677fd959f59b7ad1bee79f" prot="public" static="no">
        <name>MOVE_SEGM_ORPHAN</name>
        <initializer>-7</initializer>
        <briefdescription>
<para>Orphan bytes hinder segment movement. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="764" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="764" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___c_s_s___1gacbd7caffb298078265b62e590ae8dd62" prot="public" static="no">
        <name>CSS_OK</name>
        <initializer>0</initializer>
        <briefdescription>
<para>ok </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="790" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="790" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___c_s_s___1ga5e6e05ab80cc7007dcd4789418c2e76f" prot="public" static="no">
        <name>CSS_NODBG</name>
        <initializer>-1</initializer>
        <briefdescription>
<para>debugger is not running </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="791" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="791" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___c_s_s___1ga9b428dbce6e559a12a517f2b92a1ad9b" prot="public" static="no">
        <name>CSS_NORANGE</name>
        <initializer>-2</initializer>
        <briefdescription>
<para>could not find corresponding memory range </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="792" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="792" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___c_s_s___1ga7003f98227bcf53ea4be23de87bc81a8" prot="public" static="no">
        <name>CSS_NOMEM</name>
        <initializer>-3</initializer>
        <briefdescription>
<para>is too big) </para>        </briefdescription>
        <detaileddescription>
<para>not enough memory (might be because the segment </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="793" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="793" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group___c_s_s___1ga1d0fb084636ab14048e25f1b9f57b926" prot="public" static="no">
        <name>CSS_BREAK</name>
        <initializer>-4</initializer>
        <briefdescription>
<para>memory reading process stopped by user </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="795" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="795" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__seg__grp_1ga36d20ba74425036fd66f863bb89adeda" prot="public" static="no">
        <name>MAX_GROUPS</name>
        <initializer>8</initializer>
        <briefdescription>
<para>max number of segment groups </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="848" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="848" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__seg__trans_1ga3337a43b347cedb01c040f78cd68a6bf" prot="public" static="no">
        <name>MAX_SEGM_TRANSLATIONS</name>
        <initializer>64</initializer>
        <briefdescription>
<para>max number of segment translations </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="910" column="9" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="910" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__seg__t_1ga5971fa41ef8ad4588a189a9715c36186" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CASSERT</definition>
        <argsstring>(sizeof(segment_t)==104)</argsstring>
        <name>CASSERT</name>
        <param>
          <type>sizeof(<ref refid="classsegment__t" kindref="compound">segment_t</ref>)</type>
          <defval>=104</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="293" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__t_1gab0317864374e984294b04693bb6b1f91" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool is_visible_segm</definition>
        <argsstring>(segment_t *s)</argsstring>
        <name>is_visible_segm</name>
        <param>
          <type><ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>s</declname>
        </param>
        <briefdescription>
<para>See <ref refid="group___s_f_l___1gac31257ddd90ad0acab343cebc28c2233" kindref="member">SFL_HIDDEN</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="297" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="297" bodyend="297"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__t_1ga647d00f6f9abf3ca68071646eeecf833" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool is_finally_visible_segm</definition>
        <argsstring>(segment_t *s)</argsstring>
        <name>is_finally_visible_segm</name>
        <param>
          <type><ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>s</declname>
        </param>
        <briefdescription>
<para>See <ref refid="group___s_f_l___1gac31257ddd90ad0acab343cebc28c2233" kindref="member">SFL_HIDDEN</ref>, <ref refid="group___s_w___c_1ga39f99672364821ce90aeed4d9b0f88c6" kindref="member">SW_SHHID_SEGM</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="299" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="299" bodyend="300"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__t_1ga4a5fcdb678001b56f1e193ae57ed938a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman void ida_export</type>
        <definition>idaman void ida_export set_visible_segm</definition>
        <argsstring>(segment_t *s, bool visible)</argsstring>
        <name>set_visible_segm</name>
        <param>
          <type><ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>visible</declname>
        </param>
        <briefdescription>
<para>See <ref refid="group___s_f_l___1gac31257ddd90ad0acab343cebc28c2233" kindref="member">SFL_HIDDEN</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="302" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__t_1gaa20821d1751b3f47f92cc263e1552c7c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export is_spec_segm</definition>
        <argsstring>(uchar seg_type)</argsstring>
        <name>is_spec_segm</name>
        <param>
          <type><ref refid="pro_8h_1a65f85814a8290f9797005d3b28e7e5fc" kindref="member">uchar</ref></type>
          <declname>seg_type</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Has segment a special type?. (<ref refid="group___s_e_g___1ga5c9bbede59653b945dacc70598306289" kindref="member">SEG_XTRN</ref>, <ref refid="group___s_e_g___1gab3bd0f97c65dd59b10ea76b16d444784" kindref="member">SEG_GRP</ref>, <ref refid="group___s_e_g___1ga5c130d299e48ff537068e03e8ae23d71" kindref="member">SEG_ABSSYM</ref>, <ref refid="group___s_e_g___1ga39a39aa78e00ea21899571a2b636976e" kindref="member">SEG_COMM</ref>) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="308" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__t_1ga80f10e64c09b833e76ca5f3b7954cc9d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export is_spec_ea</definition>
        <argsstring>(ea_t ea)</argsstring>
        <name>is_spec_ea</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Does the address belong to a segment with a special type?. (<ref refid="group___s_e_g___1ga5c9bbede59653b945dacc70598306289" kindref="member">SEG_XTRN</ref>, <ref refid="group___s_e_g___1gab3bd0f97c65dd59b10ea76b16d444784" kindref="member">SEG_GRP</ref>, <ref refid="group___s_e_g___1ga5c130d299e48ff537068e03e8ae23d71" kindref="member">SEG_ABSSYM</ref>, <ref refid="group___s_e_g___1ga39a39aa78e00ea21899571a2b636976e" kindref="member">SEG_COMM</ref>) <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>linear address </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="315" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__t_1ga63b6f6b1ceaff968314c9125a5206e60" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman void ida_export</type>
        <definition>idaman void ida_export lock_segm</definition>
        <argsstring>(const segment_t *segm, bool lock)</argsstring>
        <name>lock_segm</name>
        <param>
          <type>const <ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>segm</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>lock</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Lock segment pointer Locked pointers are guaranteed to remain valid until they are unlocked. Ranges with locked pointers can not be deleted or moved. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="322" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__t_1ga61e6c48b6b509790a83f5a78f77c4224" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export is_segm_locked</definition>
        <argsstring>(const segment_t *segm)</argsstring>
        <name>is_segm_locked</name>
        <param>
          <type>const <ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>segm</declname>
        </param>
        <briefdescription>
<para>Is a segment pointer locked? </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="340" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__sel_1gad14f8b09f7f016cd4b179a4820129ecf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export getn_selector</definition>
        <argsstring>(sel_t *sel, ea_t *base, int n)</argsstring>
        <name>getn_selector</name>
        <param>
          <type>sel_t *</type>
          <declname>sel</declname>
        </param>
        <param>
          <type>ea_t *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>Get description of selector (0..<ref refid="group__seg__sel_1gabf03e7f51765884a04843fbb39f55152" kindref="member">get_selector_qty()</ref>-1) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="363" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__sel_1gabf03e7f51765884a04843fbb39f55152" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export get_selector_qty</definition>
        <argsstring>(void)</argsstring>
        <name>get_selector_qty</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
<para>Get number of defined selectors. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="368" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__sel_1ga95b819f125c442c7476c1a844cee22d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman sel_t ida_export</type>
        <definition>idaman sel_t ida_export setup_selector</definition>
        <argsstring>(ea_t segbase)</argsstring>
        <name>setup_selector</name>
        <param>
          <type>ea_t</type>
          <declname>segbase</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Allocate a selector for a segment if necessary. You must call this function before calling <ref refid="group__seg__man_1ga9c959024724f499c3c1b3c2ddb1f63b4" kindref="member">add_segm_ex()</ref>. <ref refid="group__seg__man_1ga59f6ee9677c2605aeac9541e38e54025" kindref="member">add_segm()</ref> calls this function itself, so you don&apos;t need to allocate a selector. This function will allocate a selector if &apos;segbase&apos; requires more than 16 bits and the current processor is IBM PC. Otherwise it will return the segbase value. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>segbase</parametername>
</parameternamelist>
<parameterdescription>
<para>a new segment base paragraph </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the allocated selector number </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="381" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__sel_1ga0bc493dc34c0cc8268be321fc89a72fd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman sel_t ida_export</type>
        <definition>idaman sel_t ida_export allocate_selector</definition>
        <argsstring>(ea_t segbase)</argsstring>
        <name>allocate_selector</name>
        <param>
          <type>ea_t</type>
          <declname>segbase</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Allocate a selector for a segment unconditionally. You must call this function before calling <ref refid="group__seg__man_1ga9c959024724f499c3c1b3c2ddb1f63b4" kindref="member">add_segm_ex()</ref>. <ref refid="group__seg__man_1ga59f6ee9677c2605aeac9541e38e54025" kindref="member">add_segm()</ref> calls this function itself, so you don&apos;t need to allocate a selector. This function will allocate a new free selector and setup its mapping using <ref refid="group__seg__sel_1gae9d8d263928e1700026ab15eabf10480" kindref="member">find_free_selector()</ref> and <ref refid="group__seg__sel_1gaee421bd585e301aea9452c84ac735c6a" kindref="member">set_selector()</ref> functions. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>segbase</parametername>
</parameternamelist>
<parameterdescription>
<para>a new segment base paragraph </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the allocated selector number </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="393" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__sel_1gae9d8d263928e1700026ab15eabf10480" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman sel_t ida_export</type>
        <definition>idaman sel_t ida_export find_free_selector</definition>
        <argsstring>(void)</argsstring>
        <name>find_free_selector</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Find first unused selector. <simplesect kind="return"><para>a number &gt;= 1 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="399" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__sel_1gaee421bd585e301aea9452c84ac735c6a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export set_selector</definition>
        <argsstring>(sel_t selector, ea_t paragraph)</argsstring>
        <name>set_selector</name>
        <param>
          <type>sel_t</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>paragraph</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set mapping of selector to a paragraph. You should call this function <emphasis>before</emphasis> creating a segment which uses the selector, otherwise the creation of the segment will fail. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>selector</parametername>
</parameternamelist>
<parameterdescription>
<para>number of selector to map<itemizedlist>
<listitem><para>if selector == <ref refid="pro_8h_1a893ddf307fae0a3bbca667ee917cddc7" kindref="member">BADSEL</ref>, then return 0 (fail)</para></listitem><listitem><para>if the selector has had a mapping, old mapping is destroyed</para></listitem><listitem><para>if the selector number is equal to paragraph value, then the mapping is destroyed because we don&apos;t need to keep trivial mappings. </para></listitem></itemizedlist>
</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>paragraph</parametername>
</parameternamelist>
<parameterdescription>
<para>paragraph to map selector </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>1</parametername>
</parameternamelist>
<parameterdescription>
<para>ok </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>failure (bad selector or too many mappings) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="414" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__sel_1ga30f786fe1f285b2a2df2c7c6a18d57a9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman void ida_export</type>
        <definition>idaman void ida_export del_selector</definition>
        <argsstring>(sel_t selector)</argsstring>
        <name>del_selector</name>
        <param>
          <type>sel_t</type>
          <declname>selector</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Delete mapping of a selector. Be wary of deleting selectors that are being used in the program, this can make a mess in the segments. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>selector</parametername>
</parameternamelist>
<parameterdescription>
<para>number of selector to remove from the translation table </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="422" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__sel_1ga8416e3237013eadfd32dfafc87953e3c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman ea_t ida_export</type>
        <definition>idaman ea_t ida_export sel2para</definition>
        <argsstring>(sel_t selector)</argsstring>
        <name>sel2para</name>
        <param>
          <type>sel_t</type>
          <declname>selector</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get mapping of a selector. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>selector</parametername>
</parameternamelist>
<parameterdescription>
<para>number of selector to translate </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>paragraph the specified selector is mapped to. if there is no mapping, returns &apos;selector&apos;. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="430" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__sel_1ga0bf8f3ddf2be4616b37609bf3d302c8e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>ea_t idaapi</type>
        <definition>ea_t idaapi sel2ea</definition>
        <argsstring>(sel_t selector)</argsstring>
        <name>sel2ea</name>
        <param>
          <type>sel_t</type>
          <declname>selector</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get mapping of a selector as a linear address. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>selector</parametername>
</parameternamelist>
<parameterdescription>
<para>number of selector to translate to linear address </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>linear address the specified selector is mapped to. if there is no mapping, returns to_ea(selector,0); </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="438" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="438" bodyend="443"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__sel_1gaf4a5a8ead1db6a02fe332395bb0f1e25" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman sel_t ida_export</type>
        <definition>idaman sel_t ida_export find_selector</definition>
        <argsstring>(ea_t base)</argsstring>
        <name>find_selector</name>
        <param>
          <type>ea_t</type>
          <declname>base</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Find a selector that has mapping to the specified paragraph. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>paragraph to search in the translation table </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>selector value or base </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="450" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__sel_1ga6e6e924cc3dd3971f5576a4569afc3c7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export enumerate_selectors</definition>
        <argsstring>(int(idaapi *func)(sel_t sel, ea_t para))</argsstring>
        <name>enumerate_selectors</name>
        <param>
          <type>int(idaapi *)(sel_t sel, ea_t para)</type>
          <declname>func</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Enumerate all selectors from the translation table. This function calls &apos;func&apos; for each selector in the translation table. If &apos;func&apos; returns non-zero code, enumeration is stopped and this code is returned. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>callback function<itemizedlist>
<listitem><para>sel: selector number</para></listitem><listitem><para>para: selector mapping </para></listitem></itemizedlist>
</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 or code returned by &apos;func&apos;. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="462" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__sel_1ga9500c2b6c5a4a9e32b30926e92979d1f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman ea_t ida_export</type>
        <definition>idaman ea_t ida_export enumerate_segments_with_selector</definition>
        <argsstring>(sel_t selector, ea_t(idaapi *func)(segment_t *s, void *ud), void *ud=NULL)</argsstring>
        <name>enumerate_segments_with_selector</name>
        <param>
          <type>sel_t</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>ea_t(idaapi *)(<ref refid="classsegment__t" kindref="compound">segment_t</ref> *s, void *ud)</type>
          <declname>func</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>ud</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Enumerate all segments with the specified selector. This function will call the callback function &apos;func&apos; for each segment that has the specified selector. Enumeration starts from the last segment and stops at the first segment (reverse order). If the callback function &apos;func&apos; returns a value != <ref refid="pro_8h_1a63a7c1cde5fb0cf0d0023d55c742dd4f" kindref="member">BADADDR</ref>, the enumeration is stopped and this value is returned to the caller. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>selector</parametername>
</parameternamelist>
<parameterdescription>
<para>segments that have this selector are enumerated </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>callback function<itemizedlist>
<listitem><para>s: pointer to segment structure</para></listitem><listitem><para>ud: user data </para></listitem></itemizedlist>
</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ud</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to user data. this pointer will be passed to the callback function </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="pro_8h_1a63a7c1cde5fb0cf0d0023d55c742dd4f" kindref="member">BADADDR</ref> or the value returned by the callback function &apos;func&apos; </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="479" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__sel_1ga18c1993675118da58f537e441edb4a66" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="classsegment__t" kindref="compound">segment_t</ref> *ida_export</type>
        <definition>idaman segment_t* ida_export get_segm_by_sel</definition>
        <argsstring>(sel_t selector)</argsstring>
        <name>get_segm_by_sel</name>
        <param>
          <type>sel_t</type>
          <declname>selector</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get pointer to segment structure. This function finds a segment by its selector. If there are several segments with the same selectors, the last one will be returned. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>selector</parametername>
</parameternamelist>
<parameterdescription>
<para>a segment with the specified selector will be returned </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>pointer to segment or NULL </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="491" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__man_1ga9c959024724f499c3c1b3c2ddb1f63b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export add_segm_ex</definition>
        <argsstring>(segment_t *s, const char *name, const char *sclass, int flags)</argsstring>
        <name>add_segm_ex</name>
        <param>
          <type><ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>sclass</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Add a new segment. If a segment already exists at the specified range of addresses, this segment will be truncated. Instructions and data in the old segment will be deleted if the new segment has another addressing mode or another segment base address. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to filled segment structure. segment selector should have proper mapping (see <ref refid="group__seg__sel_1gaee421bd585e301aea9452c84ac735c6a" kindref="member">set_selector()</ref>).<itemizedlist>
<listitem><para>if s.start_ea==<ref refid="pro_8h_1a63a7c1cde5fb0cf0d0023d55c742dd4f" kindref="member">BADADDR</ref> then s.start_ea &lt;- get_segm_base(&amp;s)</para></listitem><listitem><para>if s.end_ea==<ref refid="pro_8h_1a63a7c1cde5fb0cf0d0023d55c742dd4f" kindref="member">BADADDR</ref>, then a segment up to the next segment will be created (if the next segment doesn&apos;t exist, then 1 byte segment will be created).</para></listitem><listitem><para>if the s.end_ea &lt; s.start_ea, then fail.</para></listitem><listitem><para>if s.end_ea is too high and the new segment would overlap the next segment, s.end_ea is adjusted properly. </para></listitem></itemizedlist>
</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>name of new segment. may be NULL. if specified, the segment is immediately renamed </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sclass</parametername>
</parameternamelist>
<parameterdescription>
<para>class of the segment. may be NULL. if specified, the segment class is immediately changed </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>flags</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group___a_d_d_s_e_g__" kindref="compound">Add segment flags</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>1</parametername>
</parameternamelist>
<parameterdescription>
<para>ok </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>failed, a warning message is displayed </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="525" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__man_1ga59f6ee9677c2605aeac9541e38e54025" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export add_segm</definition>
        <argsstring>(ea_t para, ea_t start, ea_t end, const char *name, const char *sclass, int flags=0)</argsstring>
        <name>add_segm</name>
        <param>
          <type>ea_t</type>
          <declname>para</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>start</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>end</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>sclass</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Add a new segment, second form. Segment alignment is set to <ref refid="group__sa___1ga0aecfd12e64028f0712d6cad0403b66b" kindref="member">saRelByte</ref>. Segment combination is &quot;public&quot; or &quot;stack&quot; (if segment class is &quot;STACK&quot;). Addressing mode of segment is taken as default (16bit or 32bit). Default segment registers are set to <ref refid="pro_8h_1a893ddf307fae0a3bbca667ee917cddc7" kindref="member">BADSEL</ref>. If a segment already exists at the specified range of addresses, this segment will be truncated. Instructions and data in the old segment will be deleted if the new segment has another addressing mode or another segment base address. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>para</parametername>
</parameternamelist>
<parameterdescription>
<para>segment base paragraph. if paragraph can&apos;t fit in 16bit, then a new selector is allocated and mapped to the paragraph. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>start</parametername>
</parameternamelist>
<parameterdescription>
<para>start address of the segment. if start==<ref refid="pro_8h_1a63a7c1cde5fb0cf0d0023d55c742dd4f" kindref="member">BADADDR</ref> then start &lt;- to_ea(para,0). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>end address of the segment. end address should be higher than start address. For emulate empty segments, use <ref refid="group___s_e_g___1ga594f82f31d1ed7189ad21c3af3279269" kindref="member">SEG_NULL</ref> segment type. If the end address is lower than start address, then fail. If end==<ref refid="pro_8h_1a63a7c1cde5fb0cf0d0023d55c742dd4f" kindref="member">BADADDR</ref>, then a segment up to the next segment will be created (if the next segment doesn&apos;t exist, then 1 byte segment will be created). If &apos;end&apos; is too high and the new segment would overlap the next segment, &apos;end&apos; is adjusted properly. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>name of new segment. may be NULL </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sclass</parametername>
</parameternamelist>
<parameterdescription>
<para>class of the segment. may be NULL. type of the new segment is modified if class is one of predefined names:<itemizedlist>
<listitem><para>&quot;CODE&quot; -&gt; <ref refid="group___s_e_g___1gacfc10101b1288e858b747c0a9c329226" kindref="member">SEG_CODE</ref></para></listitem><listitem><para>&quot;DATA&quot; -&gt; <ref refid="group___s_e_g___1ga9f583dca1a7fef2948458048c70b2f1c" kindref="member">SEG_DATA</ref></para></listitem><listitem><para>&quot;CONST&quot; -&gt; <ref refid="group___s_e_g___1ga9f583dca1a7fef2948458048c70b2f1c" kindref="member">SEG_DATA</ref></para></listitem><listitem><para>&quot;STACK&quot; -&gt; <ref refid="group___s_e_g___1ga0e7d8517210b3c56679eca1111e4c0fc" kindref="member">SEG_BSS</ref></para></listitem><listitem><para>&quot;BSS&quot; -&gt; <ref refid="group___s_e_g___1ga0e7d8517210b3c56679eca1111e4c0fc" kindref="member">SEG_BSS</ref></para></listitem><listitem><para>&quot;XTRN&quot; -&gt; <ref refid="group___s_e_g___1ga5c9bbede59653b945dacc70598306289" kindref="member">SEG_XTRN</ref></para></listitem><listitem><para>&quot;COMM&quot; -&gt; <ref refid="group___s_e_g___1ga39a39aa78e00ea21899571a2b636976e" kindref="member">SEG_COMM</ref></para></listitem><listitem><para>&quot;ABS&quot; -&gt; <ref refid="group___s_e_g___1ga5c130d299e48ff537068e03e8ae23d71" kindref="member">SEG_ABSSYM</ref> </para></listitem></itemizedlist>
</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>1</parametername>
</parameternamelist>
<parameterdescription>
<para>ok </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>failed, a warning message is displayed </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="590" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__man_1gabebbd185abaf370753d5ea59d32d9985" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export del_segm</definition>
        <argsstring>(ea_t ea, int flags)</argsstring>
        <name>del_segm</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Delete a segment. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>any address belonging to the segment </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>flags</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group___s_e_g_m_o_d__" kindref="compound">Segment modification flags</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>1</parametername>
</parameternamelist>
<parameterdescription>
<para>ok </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>failed, no segment at &apos;ea&apos;. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="605" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__man_1ga9e848ee2505a32634309a914195fe141" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export get_segm_qty</definition>
        <argsstring>(void)</argsstring>
        <name>get_segm_qty</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
<para>Get number of segments. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="624" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__man_1gafe3790d2192e868f169f36b97b9afb38" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="classsegment__t" kindref="compound">segment_t</ref> *ida_export</type>
        <definition>idaman segment_t* ida_export getseg</definition>
        <argsstring>(ea_t ea)</argsstring>
        <name>getseg</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get pointer to segment by linear address. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>linear address belonging to the segment </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>NULL or pointer to segment structure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="631" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__man_1ga981ad2476fa596106a40f407583413cb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="classsegment__t" kindref="compound">segment_t</ref> *ida_export</type>
        <definition>idaman segment_t* ida_export getnseg</definition>
        <argsstring>(int n)</argsstring>
        <name>getnseg</name>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get pointer to segment by its number. <simplesect kind="warning"><para>Obsoleted because it can slow down the debugger (it has to refresh the whole memory segmentation to calculate the correct answer) </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>segment number in the range (0..<ref refid="group__seg__man_1ga9e848ee2505a32634309a914195fe141" kindref="member">get_segm_qty()</ref>-1) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>NULL or pointer to segment structure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="640" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__man_1gab73fd60fa5ec55b12441ecbf3224f742" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export get_segm_num</definition>
        <argsstring>(ea_t ea)</argsstring>
        <name>get_segm_num</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get number of segment by address. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>linear address belonging to the segment </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>-1 if no segment occupies the specified address. otherwise returns number of the specified segment (0..<ref refid="group__seg__man_1ga9e848ee2505a32634309a914195fe141" kindref="member">get_segm_qty()</ref>-1) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="647" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__man_1ga0d41eff5ac1b01d2c2f1455100d0450e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="classsegment__t" kindref="compound">segment_t</ref> *ida_export</type>
        <definition>idaman segment_t* ida_export get_next_seg</definition>
        <argsstring>(ea_t ea)</argsstring>
        <name>get_next_seg</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
<para>Get pointer to the next segment. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="651" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__man_1gabcd68779bb7c22bc90b0659caac7da7b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="classsegment__t" kindref="compound">segment_t</ref> *ida_export</type>
        <definition>idaman segment_t* ida_export get_prev_seg</definition>
        <argsstring>(ea_t ea)</argsstring>
        <name>get_prev_seg</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
<para>Get pointer to the previous segment. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="653" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__man_1gadd01f4c4e74fa760a8f2fd99ae2836e3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="classsegment__t" kindref="compound">segment_t</ref> *ida_export</type>
        <definition>idaman segment_t* ida_export get_first_seg</definition>
        <argsstring>(void)</argsstring>
        <name>get_first_seg</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
<para>Get pointer to the first segment. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="656" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__man_1ga94a1aa4658af45e1e21904bc3169fe1c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="classsegment__t" kindref="compound">segment_t</ref> *ida_export</type>
        <definition>idaman segment_t* ida_export get_last_seg</definition>
        <argsstring>(void)</argsstring>
        <name>get_last_seg</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
<para>Get pointer to the last segment. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="658" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__man_1ga6f20bda4f664e25e179a391ee9690e1f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="classsegment__t" kindref="compound">segment_t</ref> *ida_export</type>
        <definition>idaman segment_t* ida_export get_segm_by_name</definition>
        <argsstring>(const char *name)</argsstring>
        <name>get_segm_by_name</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get pointer to segment by its name. If there are several segments with the same name, returns the first of them. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>segment name. may be NULL. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>NULL or pointer to segment structure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="666" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__man_1gaadde01303718a6cde673dca12ffac9d7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export set_segm_end</definition>
        <argsstring>(ea_t ea, ea_t newend, int flags)</argsstring>
        <name>set_segm_end</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>newend</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set segment end address. The next segment is shrinked to allow expansion of the specified segment. The kernel might even delete the next segment if necessary. The kernel will ask the user for a permission to destroy instructions or data going out of segment scope if such instructions exist. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>any address belonging to the segment </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newend</parametername>
</parameternamelist>
<parameterdescription>
<para>new end address of the segment </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>flags</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group___s_e_g_m_o_d__" kindref="compound">Segment modification flags</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>1</parametername>
</parameternamelist>
<parameterdescription>
<para>ok </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>failed, a warning message is displayed </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="680" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__man_1gaffcd6c25a6d3bfc4bafeb786db81ec79" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export set_segm_start</definition>
        <argsstring>(ea_t ea, ea_t newstart, int flags)</argsstring>
        <name>set_segm_start</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>newstart</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set segment start address. The previous segment is trimmed to allow expansion of the specified segment. The kernel might even delete the previous segment if necessary. The kernel will ask the user for a permission to destroy instructions or data going out of segment scope if such instructions exist. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>any address belonging to the segment </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newstart</parametername>
</parameternamelist>
<parameterdescription>
<para>new start address of the segment note that segment start address should be higher than segment base linear address. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>flags</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group___s_e_g_m_o_d__" kindref="compound">Segment modification flags</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>1</parametername>
</parameternamelist>
<parameterdescription>
<para>ok </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>failed, a warning message is displayed </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="696" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__man_1gaa93c02cc5dccb84dc5d302dc8dcf67dc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export move_segm_start</definition>
        <argsstring>(ea_t ea, ea_t newstart, int mode)</argsstring>
        <name>move_segm_start</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>newstart</declname>
        </param>
        <param>
          <type>int</type>
          <declname>mode</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Move segment start. The main difference between this function and <ref refid="group__seg__man_1gaffcd6c25a6d3bfc4bafeb786db81ec79" kindref="member">set_segm_start()</ref> is that this function may expand the previous segment while <ref refid="group__seg__man_1gaffcd6c25a6d3bfc4bafeb786db81ec79" kindref="member">set_segm_start()</ref> never does it. So, this function allows to change bounds of two segments simultaneously. If the previous segment and the specified segment have the same addressing mode and segment base, then instructions and data are not destroyed - they simply move from one segment to another. Otherwise all instructions/data which migrate from one segment to another are destroyed. <simplesect kind="note"><para>this function never disables addresses. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>any address belonging to the segment </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newstart</parametername>
</parameternamelist>
<parameterdescription>
<para>new start address of the segment note that segment start address should be higher than segment base linear address. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>policy for destroying defined items<itemizedlist>
<listitem><para>0: if it is necessary to destroy defined items, display a dialog box and ask confirmation</para></listitem><listitem><para>1: if it is necessary to destroy defined items, just destroy them without asking the user</para></listitem><listitem><para>-1: if it is necessary to destroy defined items, don&apos;t destroy them (i.e. function will fail)</para></listitem><listitem><para>-2: don&apos;t destroy defined items (function will succeed) </para></listitem></itemizedlist>
</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>1</parametername>
</parameternamelist>
<parameterdescription>
<para>ok </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>failed, a warning message is displayed </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="724" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__man_1gab3c11fbdf0ac345cb618b8b0ad3ef04c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export move_segm</definition>
        <argsstring>(segment_t *s, ea_t to, int flags=0)</argsstring>
        <name>move_segm</name>
        <param>
          <type><ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>to</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Move a segment to a new address. This function moves all information to the new address. It fixes up address sensitive information in the kernel. The total effect is equal to reloading the segment to the target address. For the file format dependent address sensitive information, <ref refid="structloader__t_1a7a329922101a4e28a2b7018e565a3b5d" kindref="member">loader_t::move_segm</ref> is called. Also IDB notification event <ref refid="namespaceidb__event_1a0feb6e648b4e6e3f0ed954abea672784a9462c0eec099edd1bb2f0d7e65acf2e5" kindref="member">idb_event::segm_moved</ref> is called. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>segment to move </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>to</parametername>
</parameternamelist>
<parameterdescription>
<para>new segment start address </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>flags</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group___m_s_f__" kindref="compound">Move segment flags</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="group___m_o_v_e___s_e_g_m__" kindref="compound">Move segment result codes</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="738" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__man_1gaa5f20d1b84b6cbccb5a4b173f26e3599" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export rebase_program</definition>
        <argsstring>(adiff_t delta, int flags)</argsstring>
        <name>rebase_program</name>
        <param>
          <type>adiff_t</type>
          <declname>delta</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Rebase the whole program by &apos;delta&apos; bytes. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>delta</parametername>
</parameternamelist>
<parameterdescription>
<para>number of bytes to move the program </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>flags</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="group___m_s_f__" kindref="compound">Move segment flags</ref> it is recommended to use <ref refid="group___m_s_f___1ga89693134e1c29045c8c9a1b77f106813" kindref="member">MSF_FIXONCE</ref> so that the loader takes care of global variables it stored in the database </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="group___m_o_v_e___s_e_g_m__" kindref="compound">Move segment result codes</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="775" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__man_1ga4ad15e77b3eb0f53f1b5083aa0c3a70b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export change_segment_status</definition>
        <argsstring>(segment_t *s, bool is_deb_segm)</argsstring>
        <name>change_segment_status</name>
        <param>
          <type><ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>is_deb_segm</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert a debugger segment to a regular segment and vice versa. When converting debug-&gt;regular, the memory contents will be copied to the database. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>segment to modify </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>is_deb_segm</parametername>
</parameternamelist>
<parameterdescription>
<para>new status of the segment </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="group___c_s_s__" kindref="compound">Change segment status result codes</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="785" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__man_1gae35ca9fdec8cedd3d0fb74cf66506dfd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export take_memory_snapshot</definition>
        <argsstring>(bool only_loader_segs)</argsstring>
        <name>take_memory_snapshot</name>
        <param>
          <type>bool</type>
          <declname>only_loader_segs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Take a memory snapshot of the running process. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>only_loader_segs</parametername>
</parameternamelist>
<parameterdescription>
<para>only is_loader_segm() segments will be affected </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>success </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="803" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__man_1gac6e9fffcb08d5be5a4d94b5f30a84be2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export is_miniidb</definition>
        <argsstring>(void)</argsstring>
        <name>is_miniidb</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Is the database a miniidb created by the debugger?. <simplesect kind="return"><para>true if the database contains no segments or only debugger segments </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="810" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__man_1gacdb1707a8b4bec1a05923aa43c4c06f0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export set_segm_base</definition>
        <argsstring>(segment_t *s, ea_t newbase)</argsstring>
        <name>set_segm_base</name>
        <param>
          <type><ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>newbase</declname>
        </param>
        <briefdescription>
<para>Internal function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="815" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__grp_1gac0011ca67788905ff2b401b3376f8802" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export set_group_selector</definition>
        <argsstring>(sel_t grp, sel_t sel)</argsstring>
        <name>set_group_selector</name>
        <param>
          <type>sel_t</type>
          <declname>grp</declname>
        </param>
        <param>
          <type>sel_t</type>
          <declname>sel</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initialize groups. The kernel calls this function at the start of work.Create a new group of segments (used OMF files). <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>grp</parametername>
</parameternamelist>
<parameterdescription>
<para>selector of group segment (segment type is <ref refid="group___s_e_g___1gab3bd0f97c65dd59b10ea76b16d444784" kindref="member">SEG_GRP</ref>) You should create an &apos;empty&apos; (1 byte) group segment It won&apos;t contain anything and will be used to redirect references to the group of segments to the common selector. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sel</parametername>
</parameternamelist>
<parameterdescription>
<para>common selector of all segments belonging to the segment You should create all segments within the group with the same selector value. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1 ok </para></simplesect>
<simplesect kind="return"><para>0 too many groups (see <ref refid="group__seg__grp_1ga36d20ba74425036fd66f863bb89adeda" kindref="member">MAX_GROUPS</ref>) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="846" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__grp_1ga38dfb9e4396914c0118978a77897c427" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman sel_t ida_export</type>
        <definition>idaman sel_t ida_export get_group_selector</definition>
        <argsstring>(sel_t grpsel)</argsstring>
        <name>get_group_selector</name>
        <param>
          <type>sel_t</type>
          <declname>grpsel</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get common selector for a group of segments. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>grpsel</parametername>
</parameternamelist>
<parameterdescription>
<para>selector of group segment </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>common selector of the group or &apos;grpsel&apos; if no such group is found </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="855" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__trans_1ga162acfa28de46b3afb2aba0639f7f0a8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export add_segment_translation</definition>
        <argsstring>(ea_t segstart, ea_t mappedseg)</argsstring>
        <name>add_segment_translation</name>
        <param>
          <type>ea_t</type>
          <declname>segstart</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>mappedseg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Add segment translation. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>segstart</parametername>
</parameternamelist>
<parameterdescription>
<para>start address of the segment to add translation to </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mappedseg</parametername>
</parameternamelist>
<parameterdescription>
<para>start address of the overlayed segment </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>1</parametername>
</parameternamelist>
<parameterdescription>
<para>ok </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>too many translations or bad segstart </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="908" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__trans_1ga77b4d9ab9a809f3ae2e12ea7ef285576" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export set_segment_translations</definition>
        <argsstring>(ea_t segstart, const eavec_t &amp;transmap)</argsstring>
        <name>set_segment_translations</name>
        <param>
          <type>ea_t</type>
          <declname>segstart</declname>
        </param>
        <param>
          <type>const <ref refid="pro_8h_1a9f46d9d52bbfcc78bc1836f4f2683da4" kindref="member">eavec_t</ref> &amp;</type>
          <declname>transmap</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set new translation list. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>segstart</parametername>
</parameternamelist>
<parameterdescription>
<para>start address of the segment to add translation to </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>transmap</parametername>
</parameternamelist>
<parameterdescription>
<para>vector of segment start addresses for the translation list. If transmap is empty, the translation list is deleted. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>1</parametername>
</parameternamelist>
<parameterdescription>
<para>ok </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>too many translations or bad segstart </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="920" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__trans_1ga18d43bfa417e11caee34c45ff3ca5288" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman void ida_export</type>
        <definition>idaman void ida_export del_segment_translations</definition>
        <argsstring>(ea_t segstart)</argsstring>
        <name>del_segment_translations</name>
        <param>
          <type>ea_t</type>
          <declname>segstart</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Delete the translation list <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>segstart</parametername>
</parameternamelist>
<parameterdescription>
<para>start address of the segment to delete translation list </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="926" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__trans_1ga546786583c25f26b1477f83df2d35fa2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="pro_8h_1ab65ed42d67e6c517c746ff2a6a187016" kindref="member">ssize_t</ref> ida_export</type>
        <definition>idaman ssize_t ida_export get_segment_translations</definition>
        <argsstring>(eavec_t *transmap, ea_t segstart)</argsstring>
        <name>get_segment_translations</name>
        <param>
          <type><ref refid="pro_8h_1a9f46d9d52bbfcc78bc1836f4f2683da4" kindref="member">eavec_t</ref> *</type>
          <declname>transmap</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>segstart</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get segment translation list. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transmap</parametername>
</parameternamelist>
<parameterdescription>
<para>vector of segment start addresses for the translation list </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>segstart</parametername>
</parameternamelist>
<parameterdescription>
<para>start address of the segment to get information about </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>-1 if no translation list or bad segstart. otherwise returns size of translation list. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="935" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__cmt_1gaa055ce0d55f0949d6f907a584e1ec65d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="pro_8h_1ab65ed42d67e6c517c746ff2a6a187016" kindref="member">ssize_t</ref> ida_export</type>
        <definition>idaman ssize_t ida_export get_segment_cmt</definition>
        <argsstring>(qstring *buf, const segment_t *s, bool repeatable)</argsstring>
        <name>get_segment_cmt</name>
        <param>
          <type><ref refid="pro_8h_1a386c10c6aa4340f1d63df85f40454fce" kindref="member">qstring</ref> *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type>const <ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>repeatable</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get segment comment. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>buffer for the comment </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to segment structure </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>repeatable</parametername>
</parameternamelist>
<parameterdescription>
<para>0: get regular comment. 1: get repeatable comment. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>size of comment or -1 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="968" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__cmt_1ga092e05e64ba60bc29bb90cfdd03f05f8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman void ida_export</type>
        <definition>idaman void ida_export set_segment_cmt</definition>
        <argsstring>(const segment_t *s, const char *cmt, bool repeatable)</argsstring>
        <name>set_segment_cmt</name>
        <param>
          <type>const <ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>cmt</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>repeatable</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set segment comment. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to segment structure </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmt</parametername>
</parameternamelist>
<parameterdescription>
<para>comment string, may be multiline (with &apos;<linebreak/>
&apos;). maximal size is 4096 bytes. Use empty str (&quot;&quot;) to delete comment </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>repeatable</parametername>
</parameternamelist>
<parameterdescription>
<para>0: set regular comment. 1: set repeatable comment. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="980" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__cmt_1gaa7510d346be798cbe9bb08305ee964e5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman void ida_export</type>
        <definition>idaman void ida_export std_out_segm_footer</definition>
        <argsstring>(struct outctx_t &amp;ctx, segment_t *seg)</argsstring>
        <name>std_out_segm_footer</name>
        <param>
          <type>struct <ref refid="structoutctx__t" kindref="compound">outctx_t</ref> &amp;</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>seg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Generate segment footer line as a comment line. This function may be used in IDP modules to generate segment footer if the target assembler doesn&apos;t have &apos;ends&apos; directive. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="987" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__name_1ga3d5103bc9a9467bf76955237678ebe1a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export set_segm_name</definition>
        <argsstring>(segment_t *s, const char *name, int flags=0)</argsstring>
        <name>set_segm_name</name>
        <param>
          <type><ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Rename segment. The new name is validated (see validate_name). A segment always has a name. If you hadn&apos;t specified a name, the kernel will assign it &quot;seg###&quot; name where ### is segment number. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to segment (may be NULL) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>new segment name </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>flags</parametername>
</parameternamelist>
<parameterdescription>
<para>ADDSEG_IDBENC or 0 </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>1</parametername>
</parameternamelist>
<parameterdescription>
<para>ok, name is good and segment is renamed </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>failure, name is bad or segment is NULL </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="1009" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__name_1ga338226d1af237de04e3ca6c941560afe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="pro_8h_1ab65ed42d67e6c517c746ff2a6a187016" kindref="member">ssize_t</ref> ida_export</type>
        <definition>idaman ssize_t ida_export get_segm_name</definition>
        <argsstring>(qstring *buf, const segment_t *s, int flags=0)</argsstring>
        <name>get_segm_name</name>
        <param>
          <type><ref refid="pro_8h_1a386c10c6aa4340f1d63df85f40454fce" kindref="member">qstring</ref> *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type>const <ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get true segment name by pointer to segment. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>output buffer. can not be NULL </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to segment </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>flags</parametername>
</parameternamelist>
<parameterdescription>
<para>0-return name as is; 1-substitute bad symbols with _ 1 corresponds to GN_VISIBLE </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>size of segment name (-1 if s==NULL) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="1022" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__name_1ga9664611338c9701b54dd1f0e4915a7d9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="pro_8h_1ab65ed42d67e6c517c746ff2a6a187016" kindref="member">ssize_t</ref> idaapi</type>
        <definition>ssize_t idaapi get_visible_segm_name</definition>
        <argsstring>(qstring *buf, const segment_t *s)</argsstring>
        <name>get_visible_segm_name</name>
        <param>
          <type><ref refid="pro_8h_1a386c10c6aa4340f1d63df85f40454fce" kindref="member">qstring</ref> *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type>const <ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get segment name by pointer to segment. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>output buffer. can not be NULL </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to segment </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>size of segment name (-1 if s==NULL) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="1030" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="1030" bodyend="1033"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__name_1gafbbbb4017cfa20f887d0b6f0fe01693f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="pro_8h_1ab65ed42d67e6c517c746ff2a6a187016" kindref="member">ssize_t</ref></type>
        <definition>ssize_t get_segm_expr</definition>
        <argsstring>(qstring *buf, ea_t from, sel_t sel)</argsstring>
        <name>get_segm_expr</name>
        <param>
          <type><ref refid="pro_8h_1a386c10c6aa4340f1d63df85f40454fce" kindref="member">qstring</ref> *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>from</declname>
        </param>
        <param>
          <type>sel_t</type>
          <declname>sel</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get colored segment name expression in the form (segname + displacement). <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>output buffer to hold segment expression </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>from</parametername>
</parameternamelist>
<parameterdescription>
<para>linear address of instruction operand or data referring to the name. This address will be used to get fixup information, so it should point to exact position of operand in the instruction. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sel</parametername>
</parameternamelist>
<parameterdescription>
<para>value to convert to segment expression </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>size of segment expression or -1 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="1045" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__type_1ga6fd2a886a9bee23b3f9746d4e618ead2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="pro_8h_1ab65ed42d67e6c517c746ff2a6a187016" kindref="member">ssize_t</ref> ida_export</type>
        <definition>idaman ssize_t ida_export get_segm_class</definition>
        <argsstring>(qstring *buf, const segment_t *s)</argsstring>
        <name>get_segm_class</name>
        <param>
          <type><ref refid="pro_8h_1a386c10c6aa4340f1d63df85f40454fce" kindref="member">qstring</ref> *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type>const <ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get segment class. Segment class is arbitrary text (max 8 characters). <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>output buffer. can not be NULL. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to segment </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>size of segment class (-1 if s==NULL or bufsize&lt;=0) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="1063" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__type_1ga3053ee105dd0c1201b7cb5ad2feb963d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export set_segm_class</definition>
        <argsstring>(segment_t *s, const char *sclass, int flags=0)</argsstring>
        <name>set_segm_class</name>
        <param>
          <type><ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>sclass</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set segment class. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to segment (may be NULL) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sclass</parametername>
</parameternamelist>
<parameterdescription>
<para>segment class (may be NULL). If segment type is <ref refid="group___s_e_g___1ga8743c2828565f269e2e28c131abdc4ff" kindref="member">SEG_NORM</ref> and segment class is one of predefined names, then segment type is changed to:<itemizedlist>
<listitem><para>&quot;CODE&quot; -&gt; <ref refid="group___s_e_g___1gacfc10101b1288e858b747c0a9c329226" kindref="member">SEG_CODE</ref></para></listitem><listitem><para>&quot;DATA&quot; -&gt; <ref refid="group___s_e_g___1ga9f583dca1a7fef2948458048c70b2f1c" kindref="member">SEG_DATA</ref></para></listitem><listitem><para>&quot;STACK&quot; -&gt; <ref refid="group___s_e_g___1ga0e7d8517210b3c56679eca1111e4c0fc" kindref="member">SEG_BSS</ref></para></listitem><listitem><para>&quot;BSS&quot; -&gt; <ref refid="group___s_e_g___1ga0e7d8517210b3c56679eca1111e4c0fc" kindref="member">SEG_BSS</ref></para></listitem><listitem><para>if &quot;UNK&quot; then segment type is reset to <ref refid="group___s_e_g___1ga8743c2828565f269e2e28c131abdc4ff" kindref="member">SEG_NORM</ref>. </para></listitem></itemizedlist>
</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>1</parametername>
</parameternamelist>
<parameterdescription>
<para>ok, name is good and segment is renamed </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>failure, name is NULL or bad or segment is NULL </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="1079" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__type_1ga67eaaed66c079e1ac389902d19046d20" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="pro_8h_1a65f85814a8290f9797005d3b28e7e5fc" kindref="member">uchar</ref> ida_export</type>
        <definition>idaman uchar ida_export segtype</definition>
        <argsstring>(ea_t ea)</argsstring>
        <name>segtype</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get segment type. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>any linear address within the segment </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="group___s_e_g__" kindref="compound">Segment types</ref>, <ref refid="group___s_e_g___1ga344b3516eb098ebe8ce00e193af53270" kindref="member">SEG_UNDF</ref> if no segment found at &apos;ea&apos; </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="1086" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__align_1ga12abe07389aaab7a3869ca39c1de5020" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman const char *ida_export</type>
        <definition>idaman const char* ida_export get_segment_alignment</definition>
        <argsstring>(uchar align)</argsstring>
        <name>get_segment_alignment</name>
        <param>
          <type><ref refid="pro_8h_1a65f85814a8290f9797005d3b28e7e5fc" kindref="member">uchar</ref></type>
          <declname>align</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get text representation of segment alignment code. <simplesect kind="return"><para>text digestable by IBM PC assembler. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="1100" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__align_1ga762b39eeaadde7c296afeadf3ed026e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman const char *ida_export</type>
        <definition>idaman const char* ida_export get_segment_combination</definition>
        <argsstring>(uchar comb)</argsstring>
        <name>get_segment_combination</name>
        <param>
          <type><ref refid="pro_8h_1a65f85814a8290f9797005d3b28e7e5fc" kindref="member">uchar</ref></type>
          <declname>comb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get text representation of segment combination code. <simplesect kind="return"><para>text digestable by IBM PC assembler. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="1106" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__addr_1ga5aa3f21e8091747f90c4aba53018db25" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman ea_t ida_export</type>
        <definition>idaman ea_t ida_export get_segm_para</definition>
        <argsstring>(const segment_t *s)</argsstring>
        <name>get_segm_para</name>
        <param>
          <type>const <ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get segment base paragraph. Segment base paragraph may be converted to segment base linear address using <ref refid="ida_8hpp_1a442b368394897f30bcd60bbc0b633019" kindref="member">to_ea()</ref> function. In fact, to_ea(get_segm_para(s), 0) == get_segm_base(s). <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to segment </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 if s == NULL, the segment base paragraph </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="1125" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__addr_1ga2dc3df3c526b319baa6e89f261796400" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman ea_t ida_export</type>
        <definition>idaman ea_t ida_export get_segm_base</definition>
        <argsstring>(const segment_t *s)</argsstring>
        <name>get_segm_base</name>
        <param>
          <type>const <ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get segment base linear address. Segment base linear address is used to calculate virtual addresses. The virtual address of the first byte of the segment will be (start address of segment - segment base linear address) <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to segment </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 if s == NULL, otherwise segment base linear address </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="1136" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__seg__addr_1ga25f536b5ce889abea32a4aa7d50415fc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export set_segm_addressing</definition>
        <argsstring>(segment_t *s, size_t bitness)</argsstring>
        <name>set_segm_addressing</name>
        <param>
          <type><ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>bitness</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Change segment addressing mode (16, 32, 64 bits). You must use this function to change segment addressing, never change the &apos;bitness&apos; field directly. This function will delete all instructions, comments and names in the segment <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to segment </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bitness</parametername>
</parameternamelist>
<parameterdescription>
<para>new addressing mode of segment<itemizedlist>
<listitem><para>2: 64bit segment</para></listitem><listitem><para>1: 32bit segment</para></listitem><listitem><para>0: 16bit segment </para></listitem></itemizedlist>
</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>success </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="1150" column="1"/>
      </memberdef>
      <memberdef kind="function" id="segment_8hpp_1a874ebd7096a79c963a3eaa7e1210c64a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool is_debugger_segm</definition>
        <argsstring>(ea_t ea)</argsstring>
        <name>is_debugger_segm</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
<para>Does the address belong to a debug segment? </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="1159" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="1159" bodyend="1163"/>
      </memberdef>
      <memberdef kind="function" id="segment_8hpp_1a3cc0d9cfbf8cda312a07f001884959b3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool is_ephemeral_segm</definition>
        <argsstring>(ea_t ea)</argsstring>
        <name>is_ephemeral_segm</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
<para>Does the address belong to an ephemeral segment? </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="1167" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="1167" bodyend="1171"/>
      </memberdef>
      <memberdef kind="function" id="segment_8hpp_1a2f30c3f0896f67a1d99dd3d34528ce59" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>ea_t</type>
        <definition>ea_t correct_address</definition>
        <argsstring>(ea_t ea, ea_t from, ea_t to, ea_t size, bool skip_check=false)</argsstring>
        <name>correct_address</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>from</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>to</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>skip_check</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="1174" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" bodystart="1174" bodyend="1179"/>
      </memberdef>
      <memberdef kind="function" id="segment_8hpp_1a4464b4f207debe82fe447f2135a84312" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export update_segm</definition>
        <argsstring>(segment_t *s)</argsstring>
        <name>update_segm</name>
        <param>
          <type><ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="1182" column="1"/>
      </memberdef>
      <memberdef kind="function" id="segment_8hpp_1a9cff39cba1cd5de91be3f3bc31d972a9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman adiff_t ida_export</type>
        <definition>idaman adiff_t ida_export segm_adjust_diff</definition>
        <argsstring>(const segment_t *s, adiff_t delta)</argsstring>
        <name>segm_adjust_diff</name>
        <param>
          <type>const <ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>adiff_t</type>
          <declname>delta</declname>
        </param>
        <briefdescription>
<para>Truncate and sign extend a delta depending on the segment. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="1190" column="1"/>
      </memberdef>
      <memberdef kind="function" id="segment_8hpp_1adbe9cc92047ef647a56e5daff99b7b32" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman ea_t ida_export</type>
        <definition>idaman ea_t ida_export segm_adjust_ea</definition>
        <argsstring>(const segment_t *s, ea_t ea)</argsstring>
        <name>segm_adjust_ea</name>
        <param>
          <type>const <ref refid="classsegment__t" kindref="compound">segment_t</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
<para>Truncate an address depending on the segment. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp" line="1193" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Functions that deal with program segmentation. </para>    </briefdescription>
    <detaileddescription>
<para>IDA requires that all program addresses belong to segments (each address must belong to exactly one segment). The situation when an address doesn&apos;t belong to any segment is allowed as a temporary situation only when the user changes program segmentation. Bytes outside a segment can&apos;t be converted to instructions, have names, comments, etc. Each segment has its start address, ending address and represents a contiguous range of addresses. There might be unused holes between segments.</para><para>Each segment has its unique segment selector. This selector is used to distinguish the segment from other segments. For 16-bit programs the selector is equal to the segment base paragraph. For 32-bit programs there is special array to translate the selectors to the segment base paragraphs. A selector is a 32/64 bit value.</para><para>The segment base paragraph determines the offsets in the segment. If the start address of the segment == (base &lt;&lt; 4) then the first offset in the segment will be 0. The start address should be higher or equal to (base &lt;&lt; 4). We will call the offsets in the segment &apos;virtual addresses&apos;. So, the virtual address of the first byte of the segment is <verbatim>    (start address of segment - segment base linear address)
</verbatim></para><para>For IBM PC, the virtual address corresponds to the offset part of the address. For other processors (Z80, for example), virtual addresses correspond to Z80 addresses and linear addresses are used only internally. For MS Windows programs the segment base paragraph is 0 and therefore the segment virtual addresses are equal to linear addresses. </para>    </detaileddescription>
    <location file="obj/x64_linux_gcc_32_opt/idasdk/segment.hpp"/>
  </compounddef>
</doxygen>
