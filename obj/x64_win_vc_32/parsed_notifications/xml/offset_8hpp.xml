<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.12">
  <compounddef id="offset_8hpp" kind="file" language="C++">
    <compoundname>offset.hpp</compoundname>
    <includes refid="nalt_8hpp" local="no">nalt.hpp</includes>
    <includes refid="segment_8hpp" local="no">segment.hpp</includes>
    <incdepgraph>
      <node id="1146">
        <label>sys/stat.h</label>
      </node>
      <node id="1130">
        <label>stdarg.h</label>
      </node>
      <node id="1133">
        <label>assert.h</label>
      </node>
      <node id="1127">
        <label>ida.hpp</label>
        <link refid="ida_8hpp"/>
        <childnode refid="1128" relation="include">
        </childnode>
        <childnode refid="1148" relation="include">
        </childnode>
      </node>
      <node id="1129">
        <label>stdlib.h</label>
      </node>
      <node id="1141">
        <label>io.h</label>
      </node>
      <node id="1144">
        <label>fcntl.h</label>
      </node>
      <node id="1147">
        <label>llong.hpp</label>
        <link refid="llong_8hpp_source"/>
      </node>
      <node id="1139">
        <label>malloc.h</label>
      </node>
      <node id="1138">
        <label>string</label>
      </node>
      <node id="1143">
        <label>map</label>
      </node>
      <node id="1142">
        <label>direct.h</label>
      </node>
      <node id="1131">
        <label>stddef.h</label>
      </node>
      <node id="1126">
        <label>nalt.hpp</label>
        <link refid="nalt_8hpp"/>
        <childnode refid="1127" relation="include">
        </childnode>
        <childnode refid="1149" relation="include">
        </childnode>
      </node>
      <node id="1134">
        <label>limits.h</label>
      </node>
      <node id="1145">
        <label>sys/types.h</label>
      </node>
      <node id="1140">
        <label>string.h</label>
      </node>
      <node id="1137">
        <label>new</label>
      </node>
      <node id="1128">
        <label>pro.h</label>
        <link refid="pro_8h"/>
        <childnode refid="1129" relation="include">
        </childnode>
        <childnode refid="1130" relation="include">
        </childnode>
        <childnode refid="1131" relation="include">
        </childnode>
        <childnode refid="1132" relation="include">
        </childnode>
        <childnode refid="1133" relation="include">
        </childnode>
        <childnode refid="1134" relation="include">
        </childnode>
        <childnode refid="1135" relation="include">
        </childnode>
        <childnode refid="1136" relation="include">
        </childnode>
        <childnode refid="1137" relation="include">
        </childnode>
        <childnode refid="1138" relation="include">
        </childnode>
        <childnode refid="1139" relation="include">
        </childnode>
        <childnode refid="1140" relation="include">
        </childnode>
        <childnode refid="1141" relation="include">
        </childnode>
        <childnode refid="1142" relation="include">
        </childnode>
        <childnode refid="1143" relation="include">
        </childnode>
        <childnode refid="1144" relation="include">
        </childnode>
        <childnode refid="1145" relation="include">
        </childnode>
        <childnode refid="1146" relation="include">
        </childnode>
        <childnode refid="1147" relation="include">
        </childnode>
      </node>
      <node id="1150">
        <label>segment.hpp</label>
        <link refid="segment_8hpp"/>
        <childnode refid="1127" relation="include">
        </childnode>
        <childnode refid="1148" relation="include">
        </childnode>
      </node>
      <node id="1136">
        <label>time.h</label>
      </node>
      <node id="1135">
        <label>ctype.h</label>
      </node>
      <node id="1125">
        <label>obj/x64_linux_gcc_32_opt/idasdk/offset.hpp</label>
        <link refid="offset_8hpp"/>
        <childnode refid="1126" relation="include">
        </childnode>
        <childnode refid="1150" relation="include">
        </childnode>
      </node>
      <node id="1148">
        <label>range.hpp</label>
        <link refid="range_8hpp"/>
      </node>
      <node id="1149">
        <label>netnode.hpp</label>
        <link refid="netnode_8hpp"/>
        <childnode refid="1148" relation="include">
        </childnode>
      </node>
      <node id="1132">
        <label>stdio.h</label>
      </node>
    </incdepgraph>
      <sectiondef kind="func">
      <memberdef kind="function" id="offset_8hpp_1abab62af2f5bde2632931d05e4dea7c68" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman <ref refid="nalt_8hpp_1aa749dc39c69b710b5fcd35616b8267a9" kindref="member">reftype_t</ref> ida_export</type>
        <definition>idaman reftype_t ida_export get_default_reftype</definition>
        <argsstring>(ea_t ea)</argsstring>
        <name>get_default_reftype</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get default reference type depending on the segment. <simplesect kind="return"><para>one of <ref refid="group__reftype___1ga67f77788a531e1c925f610704430744a" kindref="member">REF_OFF8</ref>,<ref refid="group__reftype___1gaae74e842ed8ee99ddb41f72ecbab35af" kindref="member">REF_OFF16</ref>,<ref refid="group__reftype___1ga9514307c2327fdf250734a64943e1c67" kindref="member">REF_OFF32</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/offset.hpp" line="36" column="1"/>
      </memberdef>
      <memberdef kind="function" id="offset_8hpp_1a5401e9949fa39da243b0ff771fac6e02" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export op_offset_ex</definition>
        <argsstring>(ea_t ea, int n, const refinfo_t *ri)</argsstring>
        <name>op_offset_ex</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const <ref refid="structrefinfo__t" kindref="compound">refinfo_t</ref> *</type>
          <declname>ri</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert operand to a reference. To delete an offset, use <ref refid="group___f_f__op_1gaa2af9a3b5eaf1be072e8052ac0322b90" kindref="member">clr_op_type()</ref> function. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>linear address. if &apos;ea&apos; has unexplored bytes, try to convert them to<itemizedlist>
<listitem><para>no segment: fail</para></listitem><listitem><para>16bit segment: to 16bit word data</para></listitem><listitem><para>32bit segment: to dword </para></listitem></itemizedlist>
</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of operand (may be ORed with <ref refid="group___f_f__op_1gae3ff56ce8ed4030acdca9d9314038dfb" kindref="member">OPND_OUTER</ref>)<itemizedlist>
<listitem><para>0: first</para></listitem><listitem><para>1: second</para></listitem><listitem><para>2: third</para></listitem><listitem><para><ref refid="group___f_f__op_1ga3177b4c883cc4b74938f6fb7559587c0" kindref="member">OPND_MASK</ref>: all operands </para></listitem></itemizedlist>
</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ri</parametername>
</parameternamelist>
<parameterdescription>
<para>reference information </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>success </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/offset.hpp" line="54" column="1"/>
      </memberdef>
      <memberdef kind="function" id="offset_8hpp_1af234e8b816269e8aedda0caeac054574" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export op_offset</definition>
        <argsstring>(ea_t ea, int n, reftype_t type, ea_t target=BADADDR, ea_t base=0, adiff_t tdelta=0)</argsstring>
        <name>op_offset</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <param>
          <type><ref refid="nalt_8hpp_1aa749dc39c69b710b5fcd35616b8267a9" kindref="member">reftype_t</ref></type>
          <declname>type</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>target</declname>
          <defval><ref refid="pro_8h_1a63a7c1cde5fb0cf0d0023d55c742dd4f" kindref="member">BADADDR</ref></defval>
        </param>
        <param>
          <type>ea_t</type>
          <declname>base</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>adiff_t</type>
          <declname>tdelta</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>See <ref refid="offset_8hpp_1a5401e9949fa39da243b0ff771fac6e02" kindref="member">op_offset_ex()</ref> </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/offset.hpp" line="59" column="1"/>
      </memberdef>
      <memberdef kind="function" id="offset_8hpp_1a4277352b711db147b321cdb001515cc9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool op_plain_offset</definition>
        <argsstring>(ea_t ea, int n, ea_t base)</argsstring>
        <name>op_plain_offset</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>base</declname>
        </param>
        <briefdescription>
<para>Convert operand to a reference with the default reference type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/offset.hpp" line="70" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/offset.hpp" bodystart="70" bodyend="74"/>
      </memberdef>
      <memberdef kind="function" id="offset_8hpp_1a7fe609ff913258096056efcc1ca81b3c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>ea_t</type>
        <definition>ea_t get_offbase</definition>
        <argsstring>(ea_t ea, int n)</argsstring>
        <name>get_offbase</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get offset base value <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>linear address </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of operand </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>offset base or <ref refid="pro_8h_1a63a7c1cde5fb0cf0d0023d55c742dd4f" kindref="member">BADADDR</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/offset.hpp" line="82" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/offset.hpp" bodystart="82" bodyend="88"/>
      </memberdef>
      <memberdef kind="function" id="offset_8hpp_1ab8030e204c4f02c6cd69dd62f2f0c65c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export get_offset_expression</definition>
        <argsstring>(qstring *buf, ea_t ea, int n, ea_t from, adiff_t offset, int getn_flags=0)</argsstring>
        <name>get_offset_expression</name>
        <param>
          <type><ref refid="pro_8h_1a386c10c6aa4340f1d63df85f40454fce" kindref="member">qstring</ref> *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>from</declname>
        </param>
        <param>
          <type>adiff_t</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>int</type>
          <declname>getn_flags</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get offset expression (in the form &quot;offset name+displ&quot;). This function uses offset translation function ({translate}) if your IDP module has such a function. Translation function is used to map linear addresses in the program (only for offsets).</para><para>Example: suppose we have instruction at linear address 0x00011000: {mov ax, [bx+7422h]} and at ds:7422h: {array dw ...} We want to represent the second operand with an offset expression, so then we call: { get_offset_expresion(0x001100, 1, 0x001102, 0x7422, buf); | | | | | | | | | +output buffer | | | +value of offset expression | | +address offset value in the instruction | +the second operand +address of instruction } and the function will return a colored string: {offset array} <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>output buffer to hold offset expression </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>start of instruction or data with the offset expression </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of operand (may be ORed with <ref refid="group___f_f__op_1gae3ff56ce8ed4030acdca9d9314038dfb" kindref="member">OPND_OUTER</ref>)<itemizedlist>
<listitem><para>0: first operand</para></listitem><listitem><para>1: second operand </para></listitem></itemizedlist>
</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>from</parametername>
</parameternamelist>
<parameterdescription>
<para>linear address of instruction operand or data referring to the name. This address will be used to get fixup information, so it should point to exact position of operand in the instruction. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>value of operand or its part. The function will return text representation of this value as offset expression. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>getn_flags</parametername>
</parameternamelist>
<parameterdescription>
<para>combination of:<itemizedlist>
<listitem><para><ref refid="group___g_e_t_n___1ga1d81af73461e98bd691ef1337d72a018" kindref="member">GETN_APPZERO</ref>: meaningful only if the name refers to a structure. appends the struct field name if the field offset is zero</para></listitem><listitem><para><ref refid="group___g_e_t_n___1ga087e60e7f734e12197cbd6f3fd0238eb" kindref="member">GETN_NODUMMY</ref>: do not generate dummy names for the expression but pretend they already exist (useful to verify that the offset expression can be represented) </para></listitem></itemizedlist>
</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>can&apos;t convert to offset expression </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>1</parametername>
</parameternamelist>
<parameterdescription>
<para>ok, a simple offset expression </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>2</parametername>
</parameternamelist>
<parameterdescription>
<para>ok, a complex offset expression </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/offset.hpp" line="137" column="1"/>
      </memberdef>
      <memberdef kind="function" id="offset_8hpp_1ab8d0a781c9e180ff36813c479ed93d31" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman int ida_export</type>
        <definition>idaman int ida_export get_offset_expr</definition>
        <argsstring>(qstring *buf, ea_t ea, int n, const refinfo_t &amp;ri, ea_t from, adiff_t offset, int getn_flags=0)</argsstring>
        <name>get_offset_expr</name>
        <param>
          <type><ref refid="pro_8h_1a386c10c6aa4340f1d63df85f40454fce" kindref="member">qstring</ref> *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const <ref refid="structrefinfo__t" kindref="compound">refinfo_t</ref> &amp;</type>
          <declname>ri</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>from</declname>
        </param>
        <param>
          <type>adiff_t</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>int</type>
          <declname>getn_flags</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>See <ref refid="offset_8hpp_1ab8030e204c4f02c6cd69dd62f2f0c65c" kindref="member">get_offset_expression()</ref> </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/offset.hpp" line="148" column="1"/>
      </memberdef>
      <memberdef kind="function" id="offset_8hpp_1a34d1e626f4b77cca25b120ccfa96434a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman ea_t ida_export</type>
        <definition>idaman ea_t ida_export can_be_off32</definition>
        <argsstring>(ea_t ea)</argsstring>
        <name>can_be_off32</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Does the specified address contain a valid OFF32 value?. For symbols in special segments the displacement is not taken into account. If yes, then the target address of OFF32 will be returned. If not, then <ref refid="pro_8h_1a63a7c1cde5fb0cf0d0023d55c742dd4f" kindref="member">BADADDR</ref> is returned. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/offset.hpp" line="163" column="1"/>
      </memberdef>
      <memberdef kind="function" id="offset_8hpp_1a984cc7dbadcde307960d0c8867707935" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman ea_t ida_export</type>
        <definition>idaman ea_t ida_export calc_offset_base</definition>
        <argsstring>(ea_t ea, int n)</argsstring>
        <name>calc_offset_base</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Try to calculate the offset base This function takes into account the fixup information, current ds and cs values. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ea</parametername>
</parameternamelist>
<parameterdescription>
<para>the referencing instruction/data address </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>operand number<itemizedlist>
<listitem><para>0: first operand</para></listitem><listitem><para>1: other operand </para></listitem></itemizedlist>
</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>output base address or <ref refid="pro_8h_1a63a7c1cde5fb0cf0d0023d55c742dd4f" kindref="member">BADADDR</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/offset.hpp" line="175" column="1"/>
      </memberdef>
      <memberdef kind="function" id="offset_8hpp_1a3035e749c86de45f3a67d025ee536c86" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman ea_t ida_export</type>
        <definition>idaman ea_t ida_export calc_probable_base_by_value</definition>
        <argsstring>(ea_t ea, uval_t off)</argsstring>
        <name>calc_probable_base_by_value</name>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <param>
          <type><ref refid="pro_8h_1aef265b11f25357d520dcfd40aa8c18f3" kindref="member">uval_t</ref></type>
          <declname>off</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Try to calculate the offset base. 2 bases are checked: current ds and cs. If fails, return <ref refid="pro_8h_1a63a7c1cde5fb0cf0d0023d55c742dd4f" kindref="member">BADADDR</ref> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/offset.hpp" line="182" column="1"/>
      </memberdef>
      <memberdef kind="function" id="offset_8hpp_1a998f1a3dfcf021e4e1d4db53f7916a23" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman bool ida_export</type>
        <definition>idaman bool ida_export calc_reference_data</definition>
        <argsstring>(ea_t *target, ea_t *base, ea_t from, const refinfo_t &amp;ri, adiff_t opval)</argsstring>
        <name>calc_reference_data</name>
        <param>
          <type>ea_t *</type>
          <declname>target</declname>
        </param>
        <param>
          <type>ea_t *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>from</declname>
        </param>
        <param>
          <type>const <ref refid="structrefinfo__t" kindref="compound">refinfo_t</ref> &amp;</type>
          <declname>ri</declname>
        </param>
        <param>
          <type>adiff_t</type>
          <declname>opval</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Calculate the target and base addresses of an offset expression. The calculated target and base addresses are returned in the locations pointed by &apos;base&apos; and &apos;target&apos;. In case &apos;ri.base&apos; is <ref refid="pro_8h_1a63a7c1cde5fb0cf0d0023d55c742dd4f" kindref="member">BADADDR</ref>, the function calculates the offset base address from the referencing instruction/data address. The target address is copied from ri.target. If ri.target is <ref refid="pro_8h_1a63a7c1cde5fb0cf0d0023d55c742dd4f" kindref="member">BADADDR</ref> then the target is calculated using the base address and &apos;opval&apos;. This function also checks if &apos;opval&apos; matches the full value of the reference and takes in account the memory-mapping. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>target</parametername>
</parameternamelist>
<parameterdescription>
<para>output target address </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>base</parametername>
</parameternamelist>
<parameterdescription>
<para>output base address </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>from</parametername>
</parameternamelist>
<parameterdescription>
<para>the referencing instruction/data address </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ri</parametername>
</parameternamelist>
<parameterdescription>
<para>reference info block from the database </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>opval</parametername>
</parameternamelist>
<parameterdescription>
<para>operand value (usually <ref refid="classop__t_1a6baa38b521c143a794640d82df109ae2" kindref="member">op_t::value</ref> or <ref refid="classop__t_1acaaeff517df0b7156b4b8521a3900cdc" kindref="member">op_t::addr</ref>) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>success </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/offset.hpp" line="200" column="1"/>
      </memberdef>
      <memberdef kind="function" id="offset_8hpp_1aabd4f991193b398eb7ae6485f09d14d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>idaman ea_t ida_export</type>
        <definition>idaman ea_t ida_export add_refinfo_dref</definition>
        <argsstring>(const insn_t &amp;insn, ea_t from, const refinfo_t &amp;ri, adiff_t opval, dref_t type, int opoff)</argsstring>
        <name>add_refinfo_dref</name>
        <param>
          <type>const <ref refid="classinsn__t" kindref="compound">insn_t</ref> &amp;</type>
          <declname>insn</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>from</declname>
        </param>
        <param>
          <type>const <ref refid="structrefinfo__t" kindref="compound">refinfo_t</ref> &amp;</type>
          <declname>ri</declname>
        </param>
        <param>
          <type>adiff_t</type>
          <declname>opval</declname>
        </param>
        <param>
          <type><ref refid="group__xref__type_1ga78aab6d0d6bd9cb4904bbdbb5ac4fa71" kindref="member">dref_t</ref></type>
          <declname>type</declname>
        </param>
        <param>
          <type>int</type>
          <declname>opoff</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Add xrefs for a reference from the given instruction ({ea}). This function creates a cross references to the target and the base. <ref refid="group___s_t_k_v_a_r__2_1ga33eadf9082c4670ee2c102b5d99622ec" kindref="member">insn_t::add_off_drefs()</ref> calls this function to create xrefs for &apos;offset&apos; operand. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>insn</parametername>
</parameternamelist>
<parameterdescription>
<para>the referencing instruction </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>from</parametername>
</parameternamelist>
<parameterdescription>
<para>the referencing instruction/data address </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ri</parametername>
</parameternamelist>
<parameterdescription>
<para>reference info block from the database </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>opval</parametername>
</parameternamelist>
<parameterdescription>
<para>operand value (usually <ref refid="classop__t_1a6baa38b521c143a794640d82df109ae2" kindref="member">op_t::value</ref> or <ref refid="classop__t_1acaaeff517df0b7156b4b8521a3900cdc" kindref="member">op_t::addr</ref>) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>type</parametername>
</parameternamelist>
<parameterdescription>
<para>type of xref </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>opoff</parametername>
</parameternamelist>
<parameterdescription>
<para>offset of the operand from the start of instruction </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the target address of the reference </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/offset.hpp" line="219" column="1"/>
      </memberdef>
      <memberdef kind="function" id="offset_8hpp_1ad0d114ea5d641a8a1dab82f9bd0d0475" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>ea_t</type>
        <definition>ea_t calc_target</definition>
        <argsstring>(ea_t from, adiff_t opval, const refinfo_t &amp;ri)</argsstring>
        <name>calc_target</name>
        <param>
          <type>ea_t</type>
          <declname>from</declname>
        </param>
        <param>
          <type>adiff_t</type>
          <declname>opval</declname>
        </param>
        <param>
          <type>const <ref refid="structrefinfo__t" kindref="compound">refinfo_t</ref> &amp;</type>
          <declname>ri</declname>
        </param>
        <briefdescription>
<para>Calculates the target, using the provided <ref refid="structrefinfo__t" kindref="compound">refinfo_t</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/offset.hpp" line="230" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/offset.hpp" bodystart="230" bodyend="236"/>
      </memberdef>
      <memberdef kind="function" id="offset_8hpp_1aedb7894e1eb35ef05490e7b50fc0e425" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>ea_t</type>
        <definition>ea_t calc_target</definition>
        <argsstring>(ea_t from, ea_t ea, int n, adiff_t opval)</argsstring>
        <name>calc_target</name>
        <param>
          <type>ea_t</type>
          <declname>from</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>ea</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <param>
          <type>adiff_t</type>
          <declname>opval</declname>
        </param>
        <briefdescription>
<para>Retrieves <ref refid="structrefinfo__t" kindref="compound">refinfo_t</ref> structure and calculates the target. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/offset.hpp" line="240" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/offset.hpp" bodystart="240" bodyend="244"/>
      </memberdef>
      <memberdef kind="function" id="offset_8hpp_1a4109990af791198ef619cf6ebfba7361" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>ea_t</type>
        <definition>ea_t calc_basevalue</definition>
        <argsstring>(ea_t target, ea_t base)</argsstring>
        <name>calc_basevalue</name>
        <param>
          <type>ea_t</type>
          <declname>target</declname>
        </param>
        <param>
          <type>ea_t</type>
          <declname>base</declname>
        </param>
        <briefdescription>
<para>Calculate the value of the reference base. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="obj/x64_linux_gcc_32_opt/idasdk/offset.hpp" line="248" column="1" bodyfile="obj/x64_linux_gcc_32_opt/idasdk/offset.hpp" bodystart="248" bodyend="251"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Functions that deal with offsets. </para>    </briefdescription>
    <detaileddescription>
<para>&quot;Being an offset&quot; is a characteristic of an operand. This means that operand or its part represent offset from some address in the program. This linear address is called &quot;offset base&quot;. Some operands may have 2 offsets simultaneously. Generally, IDA doesn&apos;t handle this except for Motorola outer offsets. Thus there may be two offset values in an operand: simple offset and outer offset.</para><para>Outer offsets are handled by specifying special operand number: it should be ORed with <ref refid="group___f_f__op_1gae3ff56ce8ed4030acdca9d9314038dfb" kindref="member">OPND_OUTER</ref> value.</para><para>See <ref refid="bytes_8hpp" kindref="compound">bytes.hpp</ref> for further explanation of operand numbers. </para>    </detaileddescription>
    <location file="obj/x64_linux_gcc_32_opt/idasdk/offset.hpp"/>
  </compounddef>
</doxygen>
